% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\usepackage{soul}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{apalike}
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={Code Development in Model Infrastructure},
  pdfauthor={Leigh Alexander and Shannon T. Holloway},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{Code Development in Model Infrastructure}
\author{Leigh Alexander and Shannon T. Holloway}
\date{2025-04-18}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{introduction}{%
\chapter*{Introduction}\label{introduction}}
\addcontentsline{toc}{chapter}{Introduction}

This document is meant to provide a general discussion of the current coding practices followed by the Model Infrastructure Team. It is meant only to serve as a tool to highlight the aspects of code development that we believe are requisite for creating robust and readable code. We welcome your feedback and thoughts.

In Chapter 1, we discuss the key elements of functions using a simple illustrative example. Though the elements are presented in a linear fashion, code development is rarely a linear process! The goal is present each element, discuss its role in the development process, and highlight some considerations that should be included in any development task.

In Chapter 2, we extend the discussion of functions by building a complete tool intended for use across a broad range of object types. We focus on overall design and highlight the pros and cons of common design choices.

In Chapter 3, we transition to one of the most important phases of development -- unit testing! Here, we discuss ways to identify what elements of a new tool \textbf{need} to be tested, we discuss some techniques we have adopted for streamlining tests, and provide a framework for creating tests within the designs discussed in Chapter 2.

Chapter 4 provides general guidelines for the PR peer review process. We highlight ways to make this process a collaborative learning experience for both the reviewer and developer that yields valid, robust, and efficient tools.

\hypertarget{Functions}{%
\chapter{Elements of a Function}\label{Functions}}

A formulaic approach to code development provides a strong foundation for developing readable, robust, and well-tested code. In this chapter, we will describe a basic pattern that can be followed when implementing new tools for or extending the \texttt{somaverse} codebase. There is not ``one way'' to develop code. The format presented here is not expected to be a one-size-fits-all approach. It is only our intention to present a general framework and highlight the components that, however implemented, are viewed by the authors as critical to any development effort.

\hypertarget{function-structure}{%
\section{Function Structure}\label{function-structure}}

There are 5 key components of a function:

\begin{itemize}
\tightlist
\item
  Usage definition
\item
  Input testing
\item
  Input processing
\item
  Task implementation
\item
  Result construction and testing
\end{itemize}

To illustrate each of these sections, we will step through the development of a simple function. The following are the general expectations provided, for example, through a Jira task:

Create a tool that fits a model using a random sampling of a provided dataset. The function

\begin{itemize}
\tightlist
\item
  accepts as input a formula, a dataset, and a random seed;
\item
  obtains a random sample (size 100 with replacement) of the provided data;
\item
  uses regression method \texttt{lm()} as implemented by the \texttt{stats} package to obtain parameter estimates based on the sampled dataset; and
\item
  returns the \texttt{lm} value object augmented by attributes specifying the kind of random number generator and the seed.
\end{itemize}

\hypertarget{usage-definition}{%
\subsection{Usage definition}\label{usage-definition}}

As we will discuss in Chapter 2, there are multiple design options for implementing a new functionality. For the purposes of this section, we will use a single function and save the discussion of extendable tools for Chapter 2.

Currently, the \texttt{somaverse} convention for exported functions is to use camel case for function names, e.g., \texttt{myNewFunction()}. For internal functions, i.e., those that are not made available to the user or reside within a function, use camel case preceded by a dot, e.g., \texttt{.myInternalFunction()}. In contrast, argument names use a dot to separate words rather than camel case, e.g., \texttt{model.formula} or \texttt{r.seed}.

Both function and argument names should clearly indicate their purpose but not be verbose.

Naming functions and arguments can be a surprisingly difficult task; it can be a balancing act between clarity, length, and convention. As an example of a confusing argument name choice, consider the \texttt{survival::survfit()} function. This function is an S3 method for creating survival curves. The S3 generic is defined to dispatch on argument \texttt{formula} -- let's assume that the original implementation was a simple function developed for formula objects that was later transitioned to an S3 method to allow for other types of objects. If that is the case, the argument name \texttt{formula} for the original function was a clear and concise choice. However, at some point, \texttt{survfit()} was extended to be an S3 method within the \texttt{survival} package to also allow for other object types, i.e., \texttt{Surv}, \texttt{coxph}, \texttt{matrix}, etc. The decision was made to keep the original formal arguments! Thus, \texttt{formula} can now be a formula \textbf{OR} a previously fit model, \textbf{OR} a matrix, etc.! Further, third-party developers have added methods, e.g., objects of class \texttt{coxnet} defined in package \texttt{glmnet}. In fact, the \texttt{somaverse} has also extended this function to objects of class \texttt{coxnet2}. So the original choice of argument name \texttt{formula} does not well describe all of the types of objects that can be provided by the user. In this case \texttt{object} would have likely been a better choice.

\textbf{LPT:} Don't dwell on the function and input argument names in the beginning. Use names that mean something to YOU. Save the naming debate for the final step. At that point you'll have a clear understanding of exactly what the input arguments mean within your code, how your code may or may not be extendable, etc. Then, discuss those choices with your team and explore the \texttt{somaverse} to identify if there are conventions that should be followed or if there are possible future extensions that might influence the choice.

It is also helpful to avoid using common or vague variable names within your code to minimize the chance that a preferred input argument name coincides with a variable name. For example, say a developer opts to use \texttt{adat} as an input argument and uses \texttt{data} as a variable name within their code. After discussion with the team, they realize that it is more common across the \texttt{somaverse} to use \texttt{data} as the input argument name. Unfortunately, a simple find/replace is not an option as \texttt{data} was used internally and blindly changing names may lead to unexpected consequences. Instead, use more descriptive internal variable names. If you convert the provided data object to a model frame, use for example \texttt{model\_frame}.

For our example, we opt to use \texttt{sampleRegression()} as the function name and \texttt{formula}, \texttt{data}, and \texttt{r.seed} as the required input arguments. If, for example, it is anticipated that this function might be extended to allow a covariate matrix and response vector, this choice of input names would not be the best choice.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sampleRegression}\NormalTok{(formula, data, }\AttributeTok{r.seed =}\NormalTok{ 1234L) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \DocumentationTok{\#\#\# Input Processing}
  \DocumentationTok{\#\#\# Task Implementation}
  \DocumentationTok{\#\#\# Result Construction}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Notice that we elected to include a default value for input \texttt{r.seed}. Default values can also be surprisingly tricky to set. For example, the best tolerance bound for converge of an iterative algorithm can vary widely. Default values are often kinder to our users, but care must be taken in selecting the default values and thus the default behaviors.

\hypertarget{input-testing}{%
\subsection{Input Testing}\label{input-testing}}

Ensuring that the inputs provided by the user are exactly what you expect them to be is the first step toward developing robust code. Despite our best efforts to provide clear and thorough documentation, we may not always succeed in clarity, users may not read the entire help page, and providing exhaustive examples is often not feasible w.r.t. build times. \textbf{The first defense against misuse of code is to ensure that the information provided by the user is what we expect it to be.}

Immediately following the usage specification, \textbf{ALL} of the inputs should be tested for basic characteristics. Are they the correct types? Do they have the correct dimensions? Are the values within range? This is often most easily accomplished using \texttt{stopifnot()} with clear descriptions of what the correct structure should be. For example,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sampleRegression}\NormalTok{(formula, data, }\AttributeTok{r.seed =}\NormalTok{ 1234L) \{}
  
  \DocumentationTok{\#\#\# Input Testing}
  
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}formula\textasciigrave{} should be of the form LHS \textasciitilde{} RHS."} \OtherTok{=}
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(formula) }\SpecialCharTok{\&\&} \FunctionTok{inherits}\NormalTok{(formula, }\StringTok{"formula"}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(formula) }\SpecialCharTok{==}\NormalTok{ 3L,}
    \StringTok{"\textasciigrave{}data\textasciigrave{} should be a data.frame."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(data) }\SpecialCharTok{\&\&} \FunctionTok{is.data.frame}\NormalTok{(data),}
    \StringTok{"\textasciigrave{}r.seed\textasciigrave{} should be a positive integer."} \OtherTok{=} 
      \FunctionTok{is.numeric}\NormalTok{(r.seed) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(r.seed) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(r.seed) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
\NormalTok{      r.seed }\SpecialCharTok{\textgreater{}} \DecValTok{0} \SpecialCharTok{\&\&} \FunctionTok{isTRUE}\NormalTok{(}\FunctionTok{all.equal}\NormalTok{(r.seed, }\FunctionTok{as.integer}\NormalTok{(r.seed)))}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \DocumentationTok{\#\#\# Task Implementation}
  \DocumentationTok{\#\#\# Result Construction}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Here, we ensure that the formula is provided and contains both a response variable and model covariates -- information that is necessary for any regression tool. We ensure that the data is provided and is a data.frame object. And finally, that the seed for the random number generator is a positive integer. Notice that we do not check that \texttt{r.seed} is provided as we have set a default value.

\hypertarget{input-processing}{%
\subsection{Input Processing}\label{input-processing}}

Once it has been confirmed that the basic structure and contents of the inputs are what we expect in simple terms, we need to perform any non-trivial testing and processing of those inputs before using them to perform the task. Such tests should typically be implemented as early in the function as possible.

The choice of testing as much as possible before performing any calculations is often kinder to the user -- imagine if the first step of a task uses a subset of the inputs to complete a 20 minute calculation and only after that calculation is complete do you realize that the inputs required for the next step are invalid!

\textbf{Be kind to your users. Identify any issues arising from invalid or unexpected inputs as early as you can, especially if a task is time-consuming.}

In our example, such an input processing step might be to convert the provided data.frame into a model frame. This processing step ensures that the data contains all of the required model terms as well as the validity of the formula. We can also include an informative message telling the user if cases with missing data are removed and warn them if the provided data is smaller than the number of samples that we will be taking.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sampleRegression}\NormalTok{(formula, data, }\AttributeTok{r.seed =}\NormalTok{ 1234L) \{}
  
  \DocumentationTok{\#\#\# Input Testing}
  
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}formula\textasciigrave{} should be of the form LHS \textasciitilde{} RHS."} \OtherTok{=}
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(formula) }\SpecialCharTok{\&\&} \FunctionTok{inherits}\NormalTok{(formula, }\StringTok{"formula"}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(formula) }\SpecialCharTok{==}\NormalTok{ 3L,}
    \StringTok{"\textasciigrave{}data\textasciigrave{} should be a data.frame."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(data) }\SpecialCharTok{\&\&} \FunctionTok{is.data.frame}\NormalTok{(data),}
    \StringTok{"\textasciigrave{}r.seed\textasciigrave{} should be a positive integer."} \OtherTok{=} 
      \FunctionTok{is.numeric}\NormalTok{(r.seed) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(r.seed) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(r.seed) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
\NormalTok{      r.seed }\SpecialCharTok{\textgreater{}} \DecValTok{0} \SpecialCharTok{\&\&} \FunctionTok{isTRUE}\NormalTok{(}\FunctionTok{all.equal}\NormalTok{(r.seed, }\FunctionTok{as.integer}\NormalTok{(r.seed)))}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing }
  
  \CommentTok{\# check to ensure that all required \textasciigrave{}formula\textasciigrave{} terms are provided in \textasciigrave{}data\textasciigrave{}}
\NormalTok{  model\_frame }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(stats}\SpecialCharTok{::}\FunctionTok{model.frame}\NormalTok{(formula, data, }\AttributeTok{na.action =}\NormalTok{ na.omit),}
                          \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                            \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to extract model.frame.}\SpecialCharTok{\textbackslash{}n\textbackslash{}t}\StringTok{"}\NormalTok{,}
\NormalTok{                                 e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                          \})}
  
  \CommentTok{\# if NAs are present in data, inform user}
  \ControlFlowTok{if}\NormalTok{ ( }\FunctionTok{nrow}\NormalTok{(data) }\SpecialCharTok{!=} \FunctionTok{nrow}\NormalTok{(model\_frame) ) \{}
    \FunctionTok{message}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(data) }\SpecialCharTok{{-}} \FunctionTok{nrow}\NormalTok{(model\_frame), }\StringTok{" cases removed due to NA values."}\NormalTok{)}
\NormalTok{  \}}
  
  \CommentTok{\# warn user if data is particularly small}
  \CommentTok{\# using model\_frame to avoid counting NA cases in data}
  \ControlFlowTok{if}\NormalTok{ ( }\FunctionTok{nrow}\NormalTok{(model\_frame) }\SpecialCharTok{\textless{}}\NormalTok{ 100L ) \{}
    \FunctionTok{warning}\NormalTok{(}\StringTok{"Provided \textasciigrave{}data\textasciigrave{} may be too small for sampling."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{  \}}

  \DocumentationTok{\#\#\# Task Implementation}
  \DocumentationTok{\#\#\# Result Construction}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Notice in the above code that we have opted to save the model frame as a new variable, \texttt{model\_frame}. However, if \texttt{data} is large, this is not a good design choice -- there will now be two large objects in the environment. Because our focus is only on the structure of functions, we have opted for clarity of variable names over conservation of memory.

Note that each step is heavily documented. Why is the subsequent block of code included? Are there any assumptions we are making? What specifically are we checking? Though some of these documentation lines may seem excessive and may not remain in the final code, they help during development, especially during the development of unit tests.

It may not always be necessary to process or further test inputs before executing the task.

\hypertarget{task-implementation}{%
\subsection{Task Implementation}\label{task-implementation}}

At this stage, you should be as confident as possible that the provided inputs are valid and in an expected form. The details of this section of a function depend on the task being implemented, which we will not attempt to cover. Some things to consider as you develop this piece are:

\begin{itemize}
\tightlist
\item
  \textbf{Test to ensure that every result is valid before using or returning.} Do values fall within the expected range? Are there NA, NaN, or Inf values? Is the result always going to be the expected type (matrix, vector, list, etc.)?\\
\item
  \textbf{Wrap calls to other functions in some type of \texttt{tryCatch()}, \texttt{be\_quiet()}, etc.} This allows for more informative messaging to the user (and to developers if debugging is required).
\item
  \textbf{Document!} This cannot be stressed enough! Indicate what you expect the result to be. Describe any non-standard choices you make. The goal of documentation is to provide the \emph{next} developer with all the information they need to understand exactly what and why.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sampleRegression}\NormalTok{(formula, data, }\AttributeTok{r.seed =}\NormalTok{ 1234L) \{}
  
  \DocumentationTok{\#\#\# Input Testing}
  
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}formula\textasciigrave{} should be of the form LHS \textasciitilde{} RHS."} \OtherTok{=}
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(formula) }\SpecialCharTok{\&\&} \FunctionTok{inherits}\NormalTok{(formula, }\StringTok{"formula"}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(formula) }\SpecialCharTok{==}\NormalTok{ 3L,}
    \StringTok{"\textasciigrave{}data\textasciigrave{} should be a data.frame."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(data) }\SpecialCharTok{\&\&} \FunctionTok{is.data.frame}\NormalTok{(data),}
    \StringTok{"\textasciigrave{}r.seed\textasciigrave{} should be a positive integer."} \OtherTok{=} 
      \FunctionTok{is.numeric}\NormalTok{(r.seed) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(r.seed) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(r.seed) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
\NormalTok{      r.seed }\SpecialCharTok{\textgreater{}} \DecValTok{0} \SpecialCharTok{\&\&} \FunctionTok{isTRUE}\NormalTok{(}\FunctionTok{all.equal}\NormalTok{(r.seed, }\FunctionTok{as.integer}\NormalTok{(r.seed)))}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing }
  
  \CommentTok{\# check to ensure that all required \textasciigrave{}formula\textasciigrave{} terms are provided in \textasciigrave{}data\textasciigrave{}}
\NormalTok{  model\_frame }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(stats}\SpecialCharTok{::}\FunctionTok{model.frame}\NormalTok{(formula, data),}
                          \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                            \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to extract model.frame.}\SpecialCharTok{\textbackslash{}n\textbackslash{}t}\StringTok{"}\NormalTok{,}
\NormalTok{                                 e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                          \})}
  
  \CommentTok{\# if NAs are present in data, inform user}
  \ControlFlowTok{if}\NormalTok{ ( }\FunctionTok{nrow}\NormalTok{(data) }\SpecialCharTok{!=} \FunctionTok{nrow}\NormalTok{(model\_frame) ) \{}
    \FunctionTok{message}\NormalTok{(}\FunctionTok{value}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(data) }\SpecialCharTok{{-}} \FunctionTok{nrow}\NormalTok{(model\_frame)),}
            \StringTok{" cases removed due to NA values."}\NormalTok{)}
\NormalTok{  \}}
  
  \CommentTok{\# warn user if data is particularly small}
  \CommentTok{\# using model\_frame to avoid possible NA cases in data}
  \ControlFlowTok{if}\NormalTok{ ( }\FunctionTok{nrow}\NormalTok{(model\_frame) }\SpecialCharTok{\textless{}}\NormalTok{ 100L ) \{}
    \FunctionTok{warning}\NormalTok{(}\StringTok{"Provided \textasciigrave{}data\textasciigrave{} may be too small for sampling."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{  \}}
  
  \DocumentationTok{\#\#\# Task Implementation}
  
  \CommentTok{\# sample (with replacement) the complete cases data}
\NormalTok{  data\_sample }\OtherTok{\textless{}{-}}\NormalTok{ withr}\SpecialCharTok{::}\FunctionTok{with\_seed}\NormalTok{(r.seed,}
                                  \FunctionTok{sample}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(model\_frame), 100L, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{))}
  
  \CommentTok{\# obtain parameter estimates}
  \CommentTok{\# pass{-}on warnings such as NA coefficients, but stop on error}
\NormalTok{  fit }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(stats}\SpecialCharTok{::}\FunctionTok{lm}\NormalTok{(formula, model\_frame[data\_sample, ]),}
                  \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                    \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain parameter estimates.}\SpecialCharTok{\textbackslash{}n\textbackslash{}t}\StringTok{"}\NormalTok{,}
\NormalTok{                         e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                  \})}
  
  \DocumentationTok{\#\#\# Result Construction}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{result-construction-and-testing}{%
\subsection{Result Construction and Testing}\label{result-construction-and-testing}}

Once a task is complete, you will often need to organize the results and ensure that the values being returned are both valid and match the documentation. Again, the details are task dependent, and we do not attempt to cover those bases here.

For our example, we simply need to add the requested attributes to the value object returned by \texttt{stats::lm()}, i.e., the seed used for the sampling and the random number generator.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sampleRegression}\NormalTok{(formula, data, }\AttributeTok{r.seed =}\NormalTok{ 1234L) \{}
  
  \DocumentationTok{\#\#\# Input Testing}
  
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}formula\textasciigrave{} should be of the form LHS \textasciitilde{} RHS."} \OtherTok{=}
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(formula) }\SpecialCharTok{\&\&} \FunctionTok{inherits}\NormalTok{(formula, }\StringTok{"formula"}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(formula) }\SpecialCharTok{==}\NormalTok{ 3L,}
    \StringTok{"\textasciigrave{}data\textasciigrave{} should be a data.frame or a soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(data) }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(data) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(data)),}
    \StringTok{"\textasciigrave{}r.seed\textasciigrave{} should be a positive integer."} \OtherTok{=} 
      \FunctionTok{is.numeric}\NormalTok{(r.seed) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(r.seed) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(r.seed) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
\NormalTok{      r.seed }\SpecialCharTok{\textgreater{}} \DecValTok{0} \SpecialCharTok{\&\&} \FunctionTok{isTRUE}\NormalTok{(}\FunctionTok{all.equal}\NormalTok{(r.seed, }\FunctionTok{as.integer}\NormalTok{(r.seed)))}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing }
  
  \CommentTok{\# check to ensure that all required \textasciigrave{}formula\textasciigrave{} terms are provided in \textasciigrave{}data\textasciigrave{}}
\NormalTok{  model\_frame }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(stats}\SpecialCharTok{::}\FunctionTok{model.frame}\NormalTok{(formula, data),}
                          \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                            \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to extract model.frame.}\SpecialCharTok{\textbackslash{}n\textbackslash{}t}\StringTok{"}\NormalTok{,}
\NormalTok{                                 e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                          \})}
  
  \CommentTok{\# if NAs are present in data, inform user}
  \ControlFlowTok{if}\NormalTok{ ( }\FunctionTok{nrow}\NormalTok{(data) }\SpecialCharTok{!=} \FunctionTok{nrow}\NormalTok{(model\_frame) ) \{}
    \FunctionTok{message}\NormalTok{(}\FunctionTok{value}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(data) }\SpecialCharTok{{-}} \FunctionTok{nrow}\NormalTok{(model\_frame)),}
            \StringTok{" cases removed due to NA values."}\NormalTok{)}
\NormalTok{  \}}
  
  \CommentTok{\# warn user if data is particularly small}
  \CommentTok{\# using model\_frame to avoid possible NA cases in data}
  \ControlFlowTok{if}\NormalTok{ ( }\FunctionTok{nrow}\NormalTok{(model\_frame) }\SpecialCharTok{\textless{}}\NormalTok{ 100L ) \{}
    \FunctionTok{warning}\NormalTok{(}\StringTok{"Provided \textasciigrave{}data\textasciigrave{} may be too small for sampling."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{  \}}
  
  \DocumentationTok{\#\#\# Task Implementation}
  
  \CommentTok{\# sample (with replacement) the complete cases data}
\NormalTok{  data\_sample }\OtherTok{\textless{}{-}}\NormalTok{ withr}\SpecialCharTok{::}\FunctionTok{with\_seed}\NormalTok{(r.seed,}
                                  \FunctionTok{sample}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(model\_frame), 100L, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{))}
  
  \CommentTok{\# obtain parameter estimates}
  \CommentTok{\# pass{-}on warnings such as NA coefficients, but stop on error}
\NormalTok{  fit }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(stats}\SpecialCharTok{::}\FunctionTok{lm}\NormalTok{(formula, model\_frame[data\_sample, ]),}
                  \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                    \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain parameter estimates.}\SpecialCharTok{\textbackslash{}n\textbackslash{}t}\StringTok{"}\NormalTok{,}
\NormalTok{                         e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                  \})}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  
  \CommentTok{\# add attributes to fit indicating random generator and seed}
  \FunctionTok{attr}\NormalTok{(fit, }\StringTok{"RNGkind"}\NormalTok{) }\OtherTok{\textless{}{-}} \FunctionTok{RNGkind}\NormalTok{()}
  \FunctionTok{attr}\NormalTok{(fit, }\StringTok{"seed"}\NormalTok{)    }\OtherTok{\textless{}{-}}\NormalTok{ r.seed}
  
\NormalTok{  fit}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{concluding-remarks}{%
\subsection{Concluding Remarks}\label{concluding-remarks}}

Despite our presentation here, tool development is not a linear process. The procedures for implementing new tools will vary as widely as the types of tools we implement! There are times when it may be easiest to first work out the details of the task itself and then work your way through the remaining components of the function. Or maybe the tool evolves as you develop the details, requiring changes to the original specification as well as the various components. Our object here is not to provide a formula for \emph{how} to develop code, but to give an ingredients list for what a robust and readable implementation should contain.

\hypertarget{extended-function-example}{%
\chapter{Extended Function Example}\label{extended-function-example}}

Let's assume that the following task is to be implemented:

\begin{itemize}
\tightlist
\item
  Provided

  \begin{itemize}
  \tightlist
  \item
    a fitted model (\texttt{object}),
  \item
    data (\texttt{newdata}),
  \item
    evaluation time (\texttt{eval.time}), and
  \item
    a vector of bin boundaries (\texttt{bin.boundaries})
  \end{itemize}
\item
  Obtain estimated survival probabilities for \texttt{newdata}
\item
  Return a list containing

  \begin{itemize}
  \tightlist
  \item
    the number of cases with predictions that fall within each bin
  \item
    a vector indicating the bin in which each case in \texttt{newdata} falls
  \item
    the user-specified bin structure
  \end{itemize}
\end{itemize}

Ideally, our new tool would support all currently used survival models in the \texttt{somaverse}. However, for the sake of brevity, we will limit the supported models to only:

\begin{itemize}
\tightlist
\item
  AFT as implemented by \texttt{survival::survreg()} (\texttt{survreg} objects)
\item
  Elastic Net AFT as implemented by \texttt{SomaSurvival::fitSurvregnet()} (\texttt{survregnet} objects)
\item
  Cox proportional hazards as implemented by \texttt{survival::coxph()} (\texttt{coxph} objects)
\end{itemize}

\hypertarget{procedure-specification}{%
\section{Procedure Specification}\label{procedure-specification}}

Before writing any code, we should have a clear picture of how the task will be accomplished. Think of this step as writing the headers for an outline. Such headers should be clear and concise -- describe the step, but avoid including details of \emph{how} the step will be accomplished.

An example of such a procedure outline for this tool could be:

\begin{itemize}
\tightlist
\item
  Test validity of inputs
\item
  Predict survival probabilities
\item
  Identify bin membership based on the predicted survival probabilities
\item
  Tally the number of cases in each probability bin
\item
  Create a list containing the bin boundaries, bin membership, and totals
\item
  Verify and return list
\end{itemize}

\hypertarget{select-a-design}{%
\section{Select a Design}\label{select-a-design}}

There are two primary design structures for extendable tools currently used in the \texttt{somaverse}:

\begin{itemize}
\tightlist
\item
  An S3 based structure, where a generic specifies the availability of a tool, and individual S3 methods are implemented for each supported object type. Often the individual S3 methods are responsible for pre-processing of inputs, and each method calls a common ``core'' function that implements the primary functionality; and
\item
  A framework based solution that uses a single function to specify the general framework and uses supporting utility functions (possibly S3) to extend the framework to each object type supported.
\end{itemize}

There are pros and cons to each of these design choices. We will discuss these as we work through illustrative examples of both designs.

\hypertarget{s3-based-design-structure}{%
\section{S3 Based Design Structure}\label{s3-based-design-structure}}

\hypertarget{usage-specification}{%
\subsection{Usage Specification}\label{usage-specification}}

The core elements of this design structure are the generic, default, and extension methods. For our example, there will be at least five functions with the following procedures:

\begin{itemize}
\tightlist
\item
  A generic method

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins(object,\ ...)}.
  \end{itemize}
\item
  A default method

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.default(object,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Generate error indicating that \texttt{object} is not supported
    \end{itemize}
  \end{itemize}
\item
  An extension method for \texttt{coxph} objects

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.coxph(object,\ newdata,\ eval.time,\ bin.boundaries,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Predict survival probabilities
    \item
      Identify bin membership based on the predicted survival probabilities
    \item
      Tally the number of cases in each probability bin
    \item
      Create a list containing the bin boundaries, bin membership, and totals
    \item
      Return list
    \end{itemize}
  \end{itemize}
\item
  An extension method for \texttt{survreg} objects

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.survreg(object,\ newdata,\ eval.time,\ bin.boundaries,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Predict survival probabilities
    \item
      Identify bin membership based on the predicted survival probabilities
    \item
      Tally the number of cases in each probability bin
    \item
      Create a list containing the bin boundaries, bin membership, and totals
    \item
      Return list
    \end{itemize}
  \end{itemize}
\item
  An extension method for \texttt{survregnet} objects

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.survregnet(object,\ newdata,\ eval.time,\ bin.boundaries,\ lambda,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Call \texttt{convert2Survreg()} to convert \texttt{object} to a \texttt{survreg} object
    \item
      Call \texttt{survProbBins.survreg()} using converted object.
    \item
      Return \texttt{.survProbBins.survreg()} value object
    \end{itemize}
  \end{itemize}
\end{itemize}

Notice that the method for objects of class \texttt{survregnet} is a bit different from the other extension methods. Specifically, we will convert the object to class \texttt{survreg} and call the \texttt{survreg} method. The S3 based design lends itself to situations where simple conversions can be exploited to minimize code duplication -- for example, numeric vector to matrix.

Now that we have a general outline of the minimum components for this design, take a moment to identify any overlaps between methods. Are there common steps that may benefit from being implemented as common internal functions? Above, we see that two of the extension methods have exactly the same tasks. Can these be implemented as common internal functions?

\begin{itemize}
\tightlist
\item
  Test validity of inputs

  \begin{itemize}
  \tightlist
  \item
    This step might be different for each model type. For example, Elastic Net models will require different inputs that non-Elastic Net models. In this design, it is typically best to keep input testing local to each object type.
  \end{itemize}
\item
  Predict survival probabilities

  \begin{itemize}
  \tightlist
  \item
    This step will be different for each model type. The survival probability for the Cox model is not directly obtained from the \texttt{survival::predict()} function, as is the case for the AFT model. This step cannot be a common internal function.
  \end{itemize}
\item
  Identify bin membership based on the predicted survival probabilities
  Tally the number of cases in each probability bin
  Create a list containing the bin boundaries, bin membership, and totals

  \begin{itemize}
  \tightlist
  \item
    Binning and tallying a vector of predicted probabilities is not dependent on \emph{how} the vector of predictions was obtained. These steps can be implemented separately.
  \end{itemize}
\end{itemize}

Let's define common function \texttt{.binData()} to implement the three steps related to binning and tallying the predicted probabilities. Our design outline is then

\begin{itemize}
\tightlist
\item
  A generic method

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins(object,\ ...)}.
  \end{itemize}
\item
  A default method

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.default(object,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Generate error indicating that \texttt{object} is not supported
    \end{itemize}
  \end{itemize}
\item
  An extension method for \texttt{coxph} objects

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.coxph(object,\ newdata,\ eval.time,\ bin.boundaries,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Predict survival probabilities
    \item
      Call .binData()
    \item
      Return .binData() value object
    \end{itemize}
  \end{itemize}
\item
  An extension method for \texttt{survreg} objects

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.survreg(object,\ newdata,\ eval.time,\ bin.boundaries,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Predict survival probabilities
    \item
      Call .binData()
    \item
      Return .binData() value object
    \end{itemize}
  \end{itemize}
\item
  An extension method for \texttt{survregnet} objects

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.survregnet(object,\ newdata,\ eval.time,\ bin.boundaries,\ lambda,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Call \texttt{convert2Survreg()} to convert \texttt{object} to a \texttt{survreg} object
    \item
      Call \texttt{survProbBins.survreg()} using converted object.
    \item
      Return \texttt{.survProbBins.survreg()} value object
    \end{itemize}
  \end{itemize}
\item
  An internal function for binning and tallying a vector of values

  \begin{itemize}
  \tightlist
  \item
    .binData(values, bin.boundaries).

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Identify bin membership based on the provided probabilities
    \item
      Tally the number of cases in each probability bin
    \item
      Create a list containing the bin boundaries, bin membership, and totals
    \item
      Return list
    \end{itemize}
  \end{itemize}
\end{itemize}

As a next step, try to identify points at which intermediate results should be tested or verified prior to their use. For our example, it would be a good idea to ensure that the estimated survival probabilities obey general characteristics, such as all in range {[}0, 1{]}, and to explicitly address cases for which this expectation is not met. There are a few options for this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Incorporate tests into \texttt{.binData()} to ensure that the provided values have the expected characteristics of a probability or
\item
  Add a testing step between ``Predict survival probabilities'' and ``Call \texttt{.binData()}''
\end{enumerate}

Selecting option 1 limits \texttt{.binData()} to be applicable only to vectors containing values in {[}0, 1{]}. Option 2 introduces an additional step and thus function into our design that must be fully unit tested. Because there is no explicit reason why \texttt{.binData()} should be limited to probabilities (perhaps such a binning functionality will be useful elsewhere in the future!), option 2 is a more general solution. Specifically, include an internal function that ensures the validity of the predicted survival probabilities and call it before passing the predicted probabilities to \texttt{.binData()}.

\begin{itemize}
\tightlist
\item
  A generic method

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins(object,\ ...)}.
  \end{itemize}
\item
  A default method

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.default(object,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Generate error indicating that \texttt{object} is not supported
    \end{itemize}
  \end{itemize}
\item
  An extension method for \texttt{coxph} objects

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.coxph(object,\ newdata,\ eval.time,\ bin.boundaries,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Predict survival probabilities
    \item
      Call .testProbabilities()
    \item
      Call \texttt{.binData()}
    \item
      Return \texttt{.binData()} value object
    \end{itemize}
  \end{itemize}
\item
  An extension method for \texttt{survreg} objects

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.survreg(object,\ newdata,\ eval.time,\ bin.boundaries,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Predict survival probabilities
    \item
      Call .testProbabilities()
    \item
      Call \texttt{.binData()}
    \item
      Return \texttt{.binData()} value object
    \end{itemize}
  \end{itemize}
\item
  An extension method for \texttt{survregnet} objects

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.survregnet(object,\ newdata,\ eval.time,\ bin.boundaries,\ lambda,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Call \texttt{convert2Survreg()} to convert \texttt{object} to a \texttt{survreg} object
    \item
      Call \texttt{survProbBins.survreg()} using converted object.
    \item
      Return \texttt{.survProbBins.survreg()} value object
    \end{itemize}
  \end{itemize}
\item
  An internal function for binning and tallying a vector of values

  \begin{itemize}
  \tightlist
  \item
    \texttt{.binData(values,\ bin.boundaries)}.

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Identify bin membership based on the provided probabilities
    \item
      Tally the number of cases in each probability bin
    \item
      Create a list containing the bin boundaries, bin membership, and totals
    \item
      Return list
    \end{itemize}
  \end{itemize}
\item
  An internal function for testing validity of survival probabilities

  \begin{itemize}
  \tightlist
  \item
    .testProbabilities(predictions)

    \begin{itemize}
    \tightlist
    \item
      Ensure predicted probabilities are all finite and in {[}0,1{]}
    \end{itemize}
  \end{itemize}
\end{itemize}

We now have an outline of our design and can begin filling in the details. At this stage, we will convert the design outline to skeleton code and outline the key steps of each function using only documentation.

\hypertarget{s3-generic}{%
\paragraph{S3 Generic}\label{s3-generic}}

The first function we must define is the ``generic''

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Function uses a fitted model and new data to estimate survival probabilities}
\CommentTok{\#\textquotesingle{}   and returns a vector of bin membership and the total number of cases in}
\CommentTok{\#\textquotesingle{}   each user{-}specified probability bin.}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{ }\FunctionTok{UseMethod}\NormalTok{(}\StringTok{"survProbBins"}\NormalTok{) \}}
\end{Highlighting}
\end{Shaded}

This function establishes \texttt{survProbBins()} as an S3 method that dispatches on the class structure of input \texttt{object}. Note that it is not necessary (nor is it advised) to specify any additional input arguments when declaring an S3 generic.

We often use this function as the primary documentation point for the method. Thus, the function title, description, dispatch argument, and expected returned value have been documented here.

The dispatch argument, \texttt{object}, could have been set as \texttt{fitted.model} based solely on the problem specification. But, we can imagine a circumstance where the method might be extended to allow a user to provide the vector of predictions rather than requiring a fitted model; in that usage, \texttt{fitted.model} would be a confusing input name, so we opt to use a more general name.

\hypertarget{s3-default}{%
\subsubsection{S3 Default}\label{s3-default}}

Next, we will define the ``default'' method. This method is the ``last resort'' method, meaning it will be triggered if \texttt{object} does not inherit from any of the types for which we have extended the generic method. Suppose that the class structure of \texttt{object} is \texttt{c("foo",\ "bar")}. When \texttt{survProbBins(object)} is evaluated, \texttt{R} will follow the following path to identify the correct S3 method:

\begin{itemize}
\tightlist
\item
  \texttt{survProbBins.foo()}
\item
  \texttt{survProbBins.bar()}
\item
  \texttt{survProbBins.default()}
\end{itemize}

If \texttt{survProbBins.foo()} is not defined, \texttt{R} looks for \texttt{survProbBins.bar()}. If \texttt{survProbBins.bar()} does not exist, \texttt{R} will dispatch the default method. Often the default method is used to generate an informative error message indicating that the function does not support the object provided by the user, as we have elected to implement here. However, this behavior is not a requirement; the default method can perform calculations and return a result.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} S3 default method {-}{-} error only}
\CommentTok{\#\textquotesingle{} @rdname survProbBins}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.default }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{}
  \FunctionTok{stop}\NormalTok{(}\StringTok{"\textasciigrave{}survProbBins()\textasciigrave{} does not yet support objects of class "}\NormalTok{,}
       \FunctionTok{value}\NormalTok{(}\FunctionTok{class}\NormalTok{(object))[1L], }\StringTok{"."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{s3-extensions}{%
\subsubsection{S3 Extensions}\label{s3-extensions}}

With the generic and default methods in place, we can now specify extensions of the method for each supported class of \texttt{object}, i.e., \texttt{coxph}, \texttt{survreg}, and \texttt{survregnet}. We elect to have these extensions described in the documentation of the generic (\texttt{@rdname\ survProbBins}) and incorporate new parameter documentation when new input parameters are introduced by a specific method, e.g., \texttt{lambda} of \texttt{survProbBins.survregnet()}. It is also possible to define all parameters in the generic documentation.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}survival::coxph()\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @rdname survProbBins}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat or data.frame. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data.}
\CommentTok{\#\textquotesingle{} @param eval.time Numeric. The time at which survival probabilities are to be}
\CommentTok{\#\textquotesingle{}   estimated.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The k+1 boundaries of the k}
\CommentTok{\#\textquotesingle{}   survival probability bins.}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.coxph }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{}, \textasciigrave{}eval.time\textasciigrave{} and \textasciigrave{}bin.boundaries\textasciigrave{} are provided}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{} is a data.frame or soma\_adat}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{} contains the appropriate data}
  \CommentTok{\# Verify that \textasciigrave{}eval.time\textasciigrave{} is a positive scalar}
  \CommentTok{\# Verify that \textasciigrave{}bin.boundaries\textasciigrave{} is a numeric vector in [0, 1]}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Predict survival probabilities}
  \CommentTok{\# Call .testProbabilities() to ensure valid predictions}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call \textasciigrave{}.binData()\textasciigrave{} to bin and tally predicted probabilities}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return the \textasciigrave{}.binData()\textasciigrave{} value object}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}survival::survreg\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @rdname survProbBins}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survreg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{}, \textasciigrave{}eval.time\textasciigrave{}, and \textasciigrave{}bin.boundaries\textasciigrave{} are provided}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{} is a data.frame or soma\_adat}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{} contains the appropriate data}
  \CommentTok{\# Verify that \textasciigrave{}eval.time\textasciigrave{} is a positive scalar}
  \CommentTok{\# Verify that \textasciigrave{}bin.boundaries\textasciigrave{} is a numeric vector in [0, 1]}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Predict survival probabilities}
  \CommentTok{\# Call .testProbabilities() to ensure valid predictions}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call \textasciigrave{}.binData()\textasciigrave{} to bin and tally predicted probabilities}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return the \textasciigrave{}.binData()\textasciigrave{} value object}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}SomaSurvival::fitSurvregnet\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @rdname survProbBins}
\CommentTok{\#\textquotesingle{} @param lambda Numeric. The Elastic Net parameter, lambda, of the model. }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries,}
\NormalTok{                                    lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{}, \textasciigrave{}eval.time\textasciigrave{}, \textasciigrave{}bin.boundaries\textasciigrave{}, and \textasciigrave{}lambda\textasciigrave{} are }
  \CommentTok{\#   provided}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{} is a data.frame or soma\_adat}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{} contains the appropriate data}
  \CommentTok{\# Verify that \textasciigrave{}eval.time\textasciigrave{} is a positive scalar}
  \CommentTok{\# Verify that \textasciigrave{}bin.boundaries\textasciigrave{} is a numeric vector in [0, 1]}
  \CommentTok{\# Verify that \textasciigrave{}lambda\textasciigrave{} is non{-}negative scalar}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Call convert2survreg() to convert to a \textasciigrave{}survreg\textasciigrave{} object}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call survProbBins.survreg() passing converted object }
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return the \textasciigrave{}.survProbBins.survreg()\textasciigrave{} value object}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

An alternative and more concise usage specification for \texttt{survProbBins.survregnet()} is

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}SomaSurvival::fitSurvregnet\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @rdname survProbBins}
\CommentTok{\#\textquotesingle{} @param lambda Numeric. The Elastic Net parameter of the model. }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# Verify that \textasciigrave{}lambda\textasciigrave{} is provided and is a non{-}negative scalar}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Call convert2survreg() to convert to a \textasciigrave{}survreg\textasciigrave{} object}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call survProbBins.survreg() passing converted object and ...}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return \textasciigrave{}survProbBins.survreg()\textasciigrave{} value object}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

where the ellipsis (\texttt{...}) is assumed to contain the additional arguments required and used by \texttt{survProbBins.survreg()}, i.e., \texttt{newdata}, \texttt{eval.time}, and \texttt{bin.boundaries}. Though this is ``tidier'' in the sense that we only worry about the inputs that \texttt{survProbBins.survregnet()} actually \emph{uses}, this is a forward-facing function, and requiring users to figure out what needs to be passed through the ellipsis can be an unkind burden.

\hypertarget{common-functions}{%
\subsubsection{Common Functions}\label{common-functions}}

The required task, bin the probabilities, and the common task of verifying that the survival probabilities are valid will be accomplished through common utility functions.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Internal function to test that probabilities are valid}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param predictions Numeric. The probabilities to test.}
\CommentTok{\#\textquotesingle{} @return Numeric. The probabilities with invalid values reset to NA\_real\_}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.testProbabilities }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(predictions) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# Verify that \textasciigrave{}predictions\textasciigrave{} is provided and is a non{-}empty numeric vector}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Check for non{-}finite (NA, NaN, Inf) values}
  \CommentTok{\# Reset non{-}finite values to NA\_real\_ and tell user}
  \CommentTok{\# }
  \CommentTok{\# Check for values outside of [0, 1]}
  \CommentTok{\# Reset out of range values to NA\_real\_ and tell user}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return modified probabilities as an unnamed numeric vector}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal function to perform binning}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Provided a vector of values and a vector of bin boundaries, identify the }
\CommentTok{\#\textquotesingle{}   bin in which each value falls and the total number of values in each bin.}
\CommentTok{\#\textquotesingle{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param values A numeric or numeric vector. The values to bin and tally.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The K+1 boundaries of K bins.}
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.binData }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(values, bin.boundaries) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# Verify that \textasciigrave{}values\textasciigrave{} is provided}
  \CommentTok{\# Verify that \textasciigrave{}values\textasciigrave{} is a numeric vector}
  \CommentTok{\# Verify that \textasciigrave{}values\textasciigrave{} does not contain NA/NaN/Inf}
  \CommentTok{\# Verify that \textasciigrave{}bin.boundaries\textasciigrave{} is provided}
  \CommentTok{\# Verify that \textasciigrave{}bin.boundaries\textasciigrave{} is a numeric vector of length \textgreater{} 1}
  \CommentTok{\# Verify that \textasciigrave{}bin.boundaries\textasciigrave{} are all unique values}
  \CommentTok{\# Verify that \textasciigrave{}bin.boundaries\textasciigrave{} does not contain NA or NaN values}
  \CommentTok{\# Verify that \textasciigrave{}bin.boundaries\textasciigrave{} are in increasing order}
  \CommentTok{\# Verify that \textasciigrave{}bin.boundaries\textasciigrave{} cover range of \textasciigrave{}values\textasciigrave{}}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Identify bin membership for each value}
  \CommentTok{\# Tally the number of cases in each bin}

  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return a list with elements \textasciigrave{}bin.boundaries\textasciigrave{}, \textasciigrave{}bin.id\textasciigrave{}, and \textasciigrave{}totals\textasciigrave{}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{general-comments}{%
\subsubsection{General Comments}\label{general-comments}}

Notice that each function adheres to the function structure described in Chapter 1 -- specifically, usage definition is detailed by our design outline, and each function includes input testing, input processing, task implementation, and result construction. Each component is heavily documented. The usage definition is detailed through the \texttt{roxygen} documentation and the internal structure of each function is detailed through comments. Because we cannot always anticipate every line of code, we include all of the components regardless of whether or not we anticipate their necessity at this stage. For example, in \texttt{.binData()}, there are currently no details for component ``Input Processing.'' Keeping the header here can serve as a reminder to ensure that we have not overlooked something as we continue to fill in the details.

For purely internal functions, such as \texttt{.binData()}, the input testing element may seem superfluous -- ``Only \emph{I} am calling this function''; ``I \emph{know} what is being passed is valid''; ``I've already checked most of this''; etc. However, mistakes happen, things get overlooked, maybe another developer decides this function will be helpful for another tool. Unless a test is time- or memory-intensive, it doesn't hurt to verify that you are getting what you need!

Further, the specific characteristics of the inputs that are tested in each function are not necessarily the same. For example, in \texttt{survProbBins.*()} we do not \emph{use} \texttt{bin.boundaries} and thus only test that it is provided, that it is of the type expected by \texttt{.binData()}, and this is contains values as required for survival probabilities (in range {[}0,1{]}). We reserve much of the testing, such as uniqueness, increasing, etc., for the function \texttt{.binData()}, which \textbf{uses} that input. This is not a hard and fast rule; remember, we also want to stop a function as soon as we know that there is a problem. There will certainly be circumstances under which it is kinder to the user to more extensively test inputs well before they will be used. However, keep in mind that incorporating tests for values outside of the function in which they are used could lead to issues if the function is later extended. Say for example, we add tests for \texttt{NA} values into the \texttt{survProbBins.*()} functions. If at a later time it is decided that a better implementation is to simply report the \texttt{NA} values rather than stop with an error, we would need to change not only the \texttt{.binData()} function to accommodate this change but also the \texttt{survProbBins.*()} functions to remove the tests for the \texttt{NA} condition.

\hypertarget{input-testing-1}{%
\subsection{Input Testing}\label{input-testing-1}}

For the S3 based design, the testing of the input \texttt{object} happens automatically through the specification of the individual methods -- if a method is not implemented for objects of class \texttt{xyz}, the default method \texttt{survProbBins.default()} will trigger indicating that the object is not supported.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Function uses a fitted model and new data to estimate survival probabilities}
\CommentTok{\#\textquotesingle{}   and returns a vector of bin membership and the total number of cases in}
\CommentTok{\#\textquotesingle{}   each user{-}specified probability bin.}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{ }\FunctionTok{UseMethod}\NormalTok{(}\StringTok{"survProbBins"}\NormalTok{) \}}

\CommentTok{\#\textquotesingle{} S3 default method {-}{-} error only}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.default }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{}
  \FunctionTok{stop}\NormalTok{(}\StringTok{"\textasciigrave{}survProbBins()\textasciigrave{} does not yet support objects of class "}\NormalTok{,}
       \FunctionTok{value}\NormalTok{(}\FunctionTok{class}\NormalTok{(object))[1L], }\StringTok{"."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{\}}

\DocumentationTok{\#\#\# Individual methods for each of the classes we must support}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}survival::coxph()\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @rdname survProbBins}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat or data.frame. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data.}
\CommentTok{\#\textquotesingle{} @param eval.time Numeric. The time at which survival probabilities are to be}
\CommentTok{\#\textquotesingle{}   estimated.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The k+1 boundaries of the k}
\CommentTok{\#\textquotesingle{}   survival probability bins.}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.coxph }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Predict survival probabilities}
  \CommentTok{\# Call .testProbabilities() to ensure valid predictions}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call \textasciigrave{}.binData()\textasciigrave{} to bin and tally predicted probabilities}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return \textasciigrave{}.binData()\textasciigrave{} value object}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}survival::survreg\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survreg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input processing}
  \CommentTok{\# Predict survival probabilities}
  \CommentTok{\# Call .testProbabilities() to ensure valid predictions}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call \textasciigrave{}.binData()\textasciigrave{} to bin and tally predicted probabilities}

  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return \textasciigrave{}.binData()\textasciigrave{} value object}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}SomaSurvival::fitSurvregnet\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param lambda Numeric. The Elastic Net parameter, lambda, of the model. }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries,}
\NormalTok{                                    lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Call convert2survreg() to convert to \textasciigrave{}survreg\textasciigrave{} object}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call survProbBins.survreg() passing converted object}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return \textasciigrave{}survProbBins.survreg()\textasciigrave{} value object}
\NormalTok{\}}

\DocumentationTok{\#\#\# Common Utility Functions}

\CommentTok{\#\textquotesingle{} Internal function to test that probabilities are valid}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param predictions Numeric. The probabilities to test.}
\CommentTok{\#\textquotesingle{} @return Numeric. The probabilities with invalid values reset to NA\_real\_}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.testProbabilities }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(predictions) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}predictions\textasciigrave{} must be numeric."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(predictions) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(predictions) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(predictions) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(predictions) }\SpecialCharTok{!=}\NormalTok{ 0L}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Check for non{-}finite (NA, NaN, Inf) values}
  \CommentTok{\# Reset non{-}finite values to NA\_real\_ and tell user}
  \CommentTok{\#}
  \CommentTok{\# Check for values outside of [0, 1]}
  \CommentTok{\# Reset out of range values to NA\_real\_ and tell user}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return modified probabilities as an unnamed numeric vector}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal function to perform binning}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Provided a vector of values and a vector of bin boundaries, identify the }
\CommentTok{\#\textquotesingle{}   bin in which each value falls and the total number of values in each bin.}
\CommentTok{\#\textquotesingle{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param values A numeric or numeric vector. The values to bin and tally.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The K+1 boundaries of K bins.}
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.binData }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(values, bin.boundaries) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}values\textasciigrave{} must be a non{-}empty, numeric vector."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(values) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(values) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(values) }\SpecialCharTok{\&\&}
        \FunctionTok{length}\NormalTok{(values) }\SpecialCharTok{!=}\NormalTok{ 0L,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector of length \textgreater{} 1."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(bin.boundaries),}
    \StringTok{"All values in \textasciigrave{}bin.boundaries\textasciigrave{} must be unique."} \OtherTok{=} 
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{==} \FunctionTok{length}\NormalTok{(}\FunctionTok{unique}\NormalTok{(bin.boundaries)),}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} cannot contain NA or NaN values."} \OtherTok{=} 
      \FunctionTok{all}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \SpecialCharTok{!}\FunctionTok{is.nan}\NormalTok{(bin.boundaries)),}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be in increasing order."} \OtherTok{=} \SpecialCharTok{!}\FunctionTok{is.unsorted}\NormalTok{(bin.boundaries),}
    \StringTok{"\textasciigrave{}values\textasciigrave{} must be finite and in range of \textasciigrave{}bin.boundaries\textasciigrave{}."} \OtherTok{=} 
      \FunctionTok{all}\NormalTok{(}\FunctionTok{is.finite}\NormalTok{(values)) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(values }\SpecialCharTok{\textgreater{}=} \FunctionTok{min}\NormalTok{(bin.boundaries)) }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(values }\SpecialCharTok{\textless{}=} \FunctionTok{max}\NormalTok{(bin.boundaries))}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Identify bin membership based on the provided probabilities}
  \CommentTok{\# Tally the number of cases in each probability bin}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return a list with elements \textasciigrave{}bin.boundaries\textasciigrave{}, \textasciigrave{}bin.id\textasciigrave{}, and \textasciigrave{}totals\textasciigrave{}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{input-processing-1}{%
\subsection{Input Processing}\label{input-processing-1}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Function uses a fitted model and new data to estimate survival probabilities}
\CommentTok{\#\textquotesingle{}   and returns a vector of bin membership and the total number of cases in}
\CommentTok{\#\textquotesingle{}   each user{-}specified probability bin.}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{ }\FunctionTok{UseMethod}\NormalTok{(}\StringTok{"survProbBins"}\NormalTok{) \}}

\CommentTok{\#\textquotesingle{} S3 default method {-}{-} error only}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.default }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{}
  \FunctionTok{stop}\NormalTok{(}\StringTok{"\textasciigrave{}survProbBins()\textasciigrave{} does not yet support objects of class "}\NormalTok{,}
       \FunctionTok{value}\NormalTok{(}\FunctionTok{class}\NormalTok{(object))[1L], }\StringTok{"."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{\}}

\DocumentationTok{\#\#\# Individual methods for each of the classes we must support}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}survival::coxph()\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.coxph }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \DocumentationTok{\#\# Predict survival probabilities}
  
  \CommentTok{\# retrieve baseline hazard}
\NormalTok{  base\_hazard }\OtherTok{\textless{}{-}}\NormalTok{ survival}\SpecialCharTok{::}\FunctionTok{basehaz}\NormalTok{(object)}
  \CommentTok{\# identify time{-}point in baseline hazard nearest the specified evaluation time}
\NormalTok{  t\_idx       }\OtherTok{\textless{}{-}} \FunctionTok{which.min}\NormalTok{(}\FunctionTok{abs}\NormalTok{(eval.time }\SpecialCharTok{{-}}\NormalTok{ base\_hazard[, 2L]))}
  
\NormalTok{  base\_hazard\_at\_t }\OtherTok{\textless{}{-}}\NormalTok{ base\_hazard[t\_idx, 1L]}
  
  \CommentTok{\# ensure that baseline hazard is a valid value (not NA, NaN, Inf)}
  \ControlFlowTok{if}\NormalTok{ ( }\SpecialCharTok{!}\FunctionTok{is.finite}\NormalTok{(base\_hazard\_at\_t) ) \{}
    \FunctionTok{stop}\NormalTok{(}\StringTok{"Invalid baseline hazard "}\NormalTok{, }\FunctionTok{value}\NormalTok{(base\_hazard\_at\_t), }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{  \}}
  \FunctionTok{message}\NormalTok{(}\StringTok{"Survival probability evaluated at t = "}\NormalTok{, }\FunctionTok{value}\NormalTok{(base\_hazard[t\_idx, 2L]))}

  \CommentTok{\# get linear predictors for newdata}
\NormalTok{  lin\_predictors }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(}\FunctionTok{predict}\NormalTok{(object, newdata, }\AttributeTok{type =} \StringTok{"lp"}\NormalTok{),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain linear predictors."}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                               \})}
  \CommentTok{\# do not need to verify linear predictors, this will be done in the}
  \CommentTok{\# .testProbabilities() function}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{exp}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{base\_hazard\_at\_t }\SpecialCharTok{*} \FunctionTok{exp}\NormalTok{(lin\_predictors))}
  
  \CommentTok{\# Ensure valid predictions}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(surv\_probabilities)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call \textasciigrave{}.binData()\textasciigrave{} to bin and tally predicted probabilities}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return \textasciigrave{}.binData()\textasciigrave{} value object}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}survival::survreg\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survreg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \DocumentationTok{\#\# Predict survival probabilities}
  
  \CommentTok{\# retrieve linear predictors}
\NormalTok{  lin\_predictors }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(}\FunctionTok{predict}\NormalTok{(object, newdata, }\AttributeTok{type =} \StringTok{"lp"}\NormalTok{),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain linear predictors."}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                               \})}
  \CommentTok{\# do not need to verify linear predictors, this will be done in the}
  \CommentTok{\# .testProbabilities() function}
                                   
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FloatTok{1.0} \SpecialCharTok{{-}}\NormalTok{ stats}\SpecialCharTok{::}\FunctionTok{pweibull}\NormalTok{(eval.time,}
                                              \AttributeTok{shape =} \FloatTok{1.0} \SpecialCharTok{/} \FunctionTok{exp}\NormalTok{(object}\SpecialCharTok{$}\NormalTok{scale),}
                                              \AttributeTok{scale =} \FunctionTok{exp}\NormalTok{(lin\_predictors))}
  \CommentTok{\# Ensure valid predictions}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(surv\_probabilities)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call \textasciigrave{}.binData()\textasciigrave{} to bin and tally predicted probabilities}

  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return \textasciigrave{}.binData()\textasciigrave{} value object}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}SomaSurvival::fitSurvregnet\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries,}
\NormalTok{                                    lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Convert to survreg object}
\NormalTok{  survreg\_object }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(SomaSurvival}\SpecialCharTok{::}\FunctionTok{convert2Survreg}\NormalTok{(object, lambda),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to convert \textasciigrave{}object\textasciigrave{} to \textasciigrave{}survreg\textasciigrave{}.}\SpecialCharTok{\textbackslash{}n\textbackslash{}t}\StringTok{"}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                             \})}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call survProbBins.survreg() passing converted object}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return \textasciigrave{}survProbBins.survreg()\textasciigrave{} value object}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal function to test that probabilities are valid}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param predictions Numeric. The probabilities to test.}
\CommentTok{\#\textquotesingle{} @return Numeric. The probabilities with invalid values reset to NA\_real\_}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.testProbabilities }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(predictions) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}predictions\textasciigrave{} must be numeric."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(predictions) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(predictions) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(predictions) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(predictions) }\SpecialCharTok{!=}\NormalTok{ 0L}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Check for non{-}finite (NA, NaN, Inf) values}
  \CommentTok{\# Reset non{-}finite values to NA\_real\_ and tell user}
  \CommentTok{\#}
  \CommentTok{\# Check for values outside of [0, 1]}
  \CommentTok{\# Reset out of range values to NA\_real\_ and tell user}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return modified probabilities as an unnamed numeric vector}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal function to perform binning}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Provided a vector of values and a vector of bin boundaries, identify the }
\CommentTok{\#\textquotesingle{}   bin in which each value falls and the total number of values in each bin.}
\CommentTok{\#\textquotesingle{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param values A numeric or numeric vector. The values to bin and tally.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The K+1 boundaries of K bins.}
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.binData }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(values, bin.boundaries) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}values\textasciigrave{} must be a non{-}empty, numeric vector."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(values) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(values) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(values) }\SpecialCharTok{\&\&}
        \FunctionTok{length}\NormalTok{(values) }\SpecialCharTok{!=}\NormalTok{ 0L,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector of length \textgreater{} 1."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(bin.boundaries),}
    \StringTok{"All values in \textasciigrave{}bin.boundaries\textasciigrave{} must be unique."} \OtherTok{=} 
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{==} \FunctionTok{length}\NormalTok{(}\FunctionTok{unique}\NormalTok{(bin.boundaries)),}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} cannot contain NA or NaN values."} \OtherTok{=} 
      \FunctionTok{all}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \SpecialCharTok{!}\FunctionTok{is.nan}\NormalTok{(bin.boundaries)),}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be in increasing order."} \OtherTok{=} \SpecialCharTok{!}\FunctionTok{is.unsorted}\NormalTok{(bin.boundaries),}
    \StringTok{"\textasciigrave{}values\textasciigrave{} must be finite and in range of \textasciigrave{}bin.boundaries\textasciigrave{}."} \OtherTok{=} 
      \FunctionTok{all}\NormalTok{(}\FunctionTok{is.finite}\NormalTok{(values)) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(values }\SpecialCharTok{\textgreater{}=} \FunctionTok{min}\NormalTok{(bin.boundaries)) }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(values }\SpecialCharTok{\textless{}=} \FunctionTok{max}\NormalTok{(bin.boundaries))}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Identify bin membership based on the provided probabilities}
  \CommentTok{\# Tally the number of cases in each probability bin}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return a list with elements \textasciigrave{}bin.boundaries\textasciigrave{}, \textasciigrave{}bin.id\textasciigrave{}, and \textasciigrave{}totals\textasciigrave{}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{task-implementation-1}{%
\subsection{Task Implementation}\label{task-implementation-1}}

Next, we implement the primary task of each function.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Function uses a fitted model and new data to estimate survival probabilities}
\CommentTok{\#\textquotesingle{}   and returns a vector of bin membership and the total number of cases in}
\CommentTok{\#\textquotesingle{}   each user{-}specified probability bin.}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{ }\FunctionTok{UseMethod}\NormalTok{(}\StringTok{"survProbBins"}\NormalTok{) \}}

\CommentTok{\#\textquotesingle{} S3 default method {-}{-} error only}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.default }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{}
  \FunctionTok{stop}\NormalTok{(}\StringTok{"\textasciigrave{}survProbBins()\textasciigrave{} does not yet support objects of class "}\NormalTok{,}
       \FunctionTok{value}\NormalTok{(}\FunctionTok{class}\NormalTok{(object))[1L], }\StringTok{"."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{\}}

\DocumentationTok{\#\#\# Individual methods for each of the classes we must support}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}survival::coxph()\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.coxph }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&} \FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&}
        \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \DocumentationTok{\#\# Predict survival probabilities}
  
  \CommentTok{\# retrieve baseline hazard}
\NormalTok{  base\_hazard }\OtherTok{\textless{}{-}}\NormalTok{ survival}\SpecialCharTok{::}\FunctionTok{basehaz}\NormalTok{(object)}
  \CommentTok{\# identify time{-}point in baseline hazard nearest the specified evaluation time}
\NormalTok{  t\_idx       }\OtherTok{\textless{}{-}} \FunctionTok{which.min}\NormalTok{(}\FunctionTok{abs}\NormalTok{(eval.time }\SpecialCharTok{{-}}\NormalTok{ base\_hazard[, 2L]))}
  
\NormalTok{  base\_hazard\_at\_t }\OtherTok{\textless{}{-}}\NormalTok{ base\_hazard[t\_idx, 1L]}
  
  \CommentTok{\# ensure that baseline hazard is a valid value (not NA, NaN, Inf)}
  \ControlFlowTok{if}\NormalTok{ ( }\SpecialCharTok{!}\FunctionTok{is.finite}\NormalTok{(base\_hazard\_at\_t) ) \{}
    \FunctionTok{stop}\NormalTok{(}\StringTok{"Invalid baseline hazard "}\NormalTok{, }\FunctionTok{value}\NormalTok{(base\_hazard\_at\_t), }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{  \}}
  \FunctionTok{message}\NormalTok{(}\StringTok{"Survival probability evaluated at t = "}\NormalTok{, }\FunctionTok{value}\NormalTok{(base\_hazard[t\_idx, 2L]))}

  \CommentTok{\# get linear predictors for newdata}
\NormalTok{  lin\_predictors }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(}\FunctionTok{predict}\NormalTok{(object, newdata, }\AttributeTok{type =} \StringTok{"lp"}\NormalTok{, ...),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain linear predictors."}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                               \})}
  \CommentTok{\# do not need to verify linear predictors, this will be done in the}
  \CommentTok{\# .testProbabilities() function}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{exp}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{base\_hazard\_at\_t }\SpecialCharTok{*} \FunctionTok{exp}\NormalTok{(lin\_predictors))}
  
  \CommentTok{\# Ensure valid predictions}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(surv\_probabilities)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  
  \CommentTok{\# Bin and tally predicted probabilities}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.binData}\NormalTok{(surv\_probabilities, bin.boundaries)}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return \textasciigrave{}.binData()\textasciigrave{} value object}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}survival::survreg\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survreg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&} \FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be numeric."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&}
        \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \DocumentationTok{\#\# Predict survival probabilities}
  
\NormalTok{  lin\_predictors }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(}\FunctionTok{predict}\NormalTok{(object, newdata, }\AttributeTok{type =} \StringTok{"lp"}\NormalTok{, ...),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain linear predictors."}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                               \})}
  \CommentTok{\# do not need to verify linear predictors, this will be done in the}
  \CommentTok{\# .testProbabilities() function}
                                   
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FloatTok{1.0} \SpecialCharTok{{-}}\NormalTok{ stats}\SpecialCharTok{::}\FunctionTok{pweibull}\NormalTok{(eval.time,}
                                              \AttributeTok{shape =} \FloatTok{1.0} \SpecialCharTok{/} \FunctionTok{exp}\NormalTok{(object}\SpecialCharTok{$}\NormalTok{scale),}
                                              \AttributeTok{scale =} \FunctionTok{exp}\NormalTok{(lin\_predictors))}
  \CommentTok{\# Ensure valid predictions}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(surv\_probabilities)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Bin and tally predicted probabilities}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.binData}\NormalTok{(surv\_probabilities, bin.boundaries)}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return \textasciigrave{}.binData()\textasciigrave{} value object}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}SomaSurvival::fitSurvregnet\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries,}
\NormalTok{                                    lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&} \FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be numeric."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&}
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{),}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Convert to survreg object and use survreg method}
\NormalTok{  survreg\_object }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(SomaSurvival}\SpecialCharTok{::}\FunctionTok{convert2Survreg}\NormalTok{(object, lambda),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to convert \textasciigrave{}object\textasciigrave{} to \textasciigrave{}survreg\textasciigrave{}.}\SpecialCharTok{\textbackslash{}n\textbackslash{}t}\StringTok{"}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                             \})}
  
  \DocumentationTok{\#\#\# Task Implementation}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{survProbBins}\NormalTok{(survreg\_object, newdata, eval.time, bin.boundaries, ...)}

  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return \textasciigrave{}survProbBins.survreg()\textasciigrave{} value object}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal function to test that probabilities are valid}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param predictions Numeric. The probabilities to test.}
\CommentTok{\#\textquotesingle{} @return Numeric. The probabilities with invalid values reset to NA\_real\_}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.testProbabilities }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(predictions) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}predictions\textasciigrave{} must be numeric."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(predictions) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(predictions) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(predictions) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(predictions) }\SpecialCharTok{!=}\NormalTok{ 0L}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# convert non{-}finite (NA, NaN, Inf) values to NA\_real\_}
  \CommentTok{\# convert values outside of [0, 1] to NA\_real\_}
\NormalTok{  bad\_values }\OtherTok{\textless{}{-}} \SpecialCharTok{!}\FunctionTok{is.finite}\NormalTok{(predictions) }\SpecialCharTok{|}\NormalTok{ predictions }\SpecialCharTok{\textless{}} \FloatTok{0.0} \SpecialCharTok{|}\NormalTok{ predictions }\SpecialCharTok{\textgreater{}} \FloatTok{1.0}
  \ControlFlowTok{if}\NormalTok{ ( }\FunctionTok{any}\NormalTok{(bad\_values) ) \{}
\NormalTok{    predictions[bad\_values] }\OtherTok{\textless{}{-}} \ConstantTok{NA\_real\_}
    \FunctionTok{message}\NormalTok{(}\FunctionTok{value}\NormalTok{(}\FunctionTok{sum}\NormalTok{(bad\_value)), }\StringTok{" invalid probabilities have been set to NA."}\NormalTok{)}
\NormalTok{  \}}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return modified probabilities as an unnamed numeric vector}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal function to perform binning}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Provided a vector of values and a vector of bin boundaries, identify the }
\CommentTok{\#\textquotesingle{}   bin in which each value falls and the total number of values in each bin.}
\CommentTok{\#\textquotesingle{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param values A numeric or numeric vector. The values to bin and tally.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The K+1 boundaries of K bins.}
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.binData }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(values, bin.boundaries) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}values\textasciigrave{} must be a non{-}empty, numeric vector."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(values) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(values) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(values) }\SpecialCharTok{\&\&}
        \FunctionTok{length}\NormalTok{(values) }\SpecialCharTok{!=}\NormalTok{ 0L,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector of length \textgreater{} 1."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(bin.boundaries),}
    \StringTok{"All values in \textasciigrave{}bin.boundaries\textasciigrave{} must be unique."} \OtherTok{=} 
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{==} \FunctionTok{length}\NormalTok{(}\FunctionTok{unique}\NormalTok{(bin.boundaries)),}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} cannot contain NA or NaN values."} \OtherTok{=} 
      \FunctionTok{all}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \SpecialCharTok{!}\FunctionTok{is.nan}\NormalTok{(bin.boundaries)),}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be in increasing order."} \OtherTok{=} \SpecialCharTok{!}\FunctionTok{is.unsorted}\NormalTok{(bin.boundaries),}
    \StringTok{"\textasciigrave{}values\textasciigrave{} must be finite and in range of \textasciigrave{}bin.boundaries\textasciigrave{}."} \OtherTok{=} 
      \FunctionTok{all}\NormalTok{(}\FunctionTok{is.finite}\NormalTok{(values)) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(values }\SpecialCharTok{\textgreater{}=} \FunctionTok{min}\NormalTok{(bin.boundaries)) }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(values }\SpecialCharTok{\textless{}=} \FunctionTok{max}\NormalTok{(bin.boundaries))}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Identify bin membership based on the provided probabilities}
  \CommentTok{\# returns k satisfying bin\_k \textless{}= x \textless{} bin\_\{k+1\}}
  \CommentTok{\# all.inside = TRUE sets anything that does not fall with the}
  \CommentTok{\# range of bin.boundaries to the nearest bin }
  \CommentTok{\# (i.e., 1 if x \textless{} bin\_1 or K if x \textgreater{}= bin\_K)}
\NormalTok{  bins }\OtherTok{\textless{}{-}} \FunctionTok{findInterval}\NormalTok{(values, bin.boundaries, }\AttributeTok{all.inside =} \ConstantTok{TRUE}\NormalTok{)}
  
  \CommentTok{\# Tally the number of cases in each probability bin}
\NormalTok{  totals        }\OtherTok{\textless{}{-}} \FunctionTok{tabulate}\NormalTok{(bins)}
  \FunctionTok{names}\NormalTok{(totals) }\OtherTok{\textless{}{-}}\NormalTok{ 1L}\SpecialCharTok{:}\NormalTok{(}\FunctionTok{length}\NormalTok{(bins)}\SpecialCharTok{{-}}\NormalTok{1L)}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return a list with elements \textasciigrave{}bin.boundaries\textasciigrave{}, \textasciigrave{}bin.id\textasciigrave{}, and \textasciigrave{}totals\textasciigrave{}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{results-construction-and-testing}{%
\subsection{Results Construction and Testing}\label{results-construction-and-testing}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Function uses a fitted model and new data to estimate survival probabilities}
\CommentTok{\#\textquotesingle{}   and returns a vector of bin membership and the total number of cases in}
\CommentTok{\#\textquotesingle{}   each user{-}specified probability bin.}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{ }\FunctionTok{UseMethod}\NormalTok{(}\StringTok{"survProbBins"}\NormalTok{) \}}

\CommentTok{\#\textquotesingle{} S3 default method {-}{-} error only}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.default }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{}
  \FunctionTok{stop}\NormalTok{(}\StringTok{"\textasciigrave{}survProbBins()\textasciigrave{} does not yet support objects of class "}\NormalTok{,}
       \FunctionTok{value}\NormalTok{(}\FunctionTok{class}\NormalTok{(object))[1L], }\StringTok{"."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{\}}

\DocumentationTok{\#\#\# Individual methods for each of the classes we must support}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}survival::coxph()\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.coxph }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&} \FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&}
        \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \DocumentationTok{\#\# Predict survival probabilities}
  
  \CommentTok{\# retrieve baseline hazard}
\NormalTok{  base\_hazard }\OtherTok{\textless{}{-}}\NormalTok{ survival}\SpecialCharTok{::}\FunctionTok{basehaz}\NormalTok{(object)}
  \CommentTok{\# identify time{-}point in baseline hazard nearest the specified evaluation time}
\NormalTok{  t\_idx       }\OtherTok{\textless{}{-}} \FunctionTok{which.min}\NormalTok{(}\FunctionTok{abs}\NormalTok{(eval.time }\SpecialCharTok{{-}}\NormalTok{ base\_hazard[, 2L]))}
  
\NormalTok{  base\_hazard\_at\_t }\OtherTok{\textless{}{-}}\NormalTok{ base\_hazard[t\_idx, 1L]}
  
  \CommentTok{\# ensure that baseline hazard is a valid value (not NA, NaN, Inf)}
  \ControlFlowTok{if}\NormalTok{ ( }\SpecialCharTok{!}\FunctionTok{is.finite}\NormalTok{(base\_hazard\_at\_t) ) \{}
    \FunctionTok{stop}\NormalTok{(}\StringTok{"Invalid baseline hazard "}\NormalTok{, }\FunctionTok{value}\NormalTok{(base\_hazard\_at\_t), }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{  \}}
  \FunctionTok{message}\NormalTok{(}\StringTok{"Survival probability evaluated at t = "}\NormalTok{, }\FunctionTok{value}\NormalTok{(base\_hazard[t\_idx, 2L]))}

  \CommentTok{\# get linear predictors for newdata}
\NormalTok{  lin\_predictors }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(}\FunctionTok{predict}\NormalTok{(object, newdata, }\AttributeTok{type =} \StringTok{"lp"}\NormalTok{, ...),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain linear predictors."}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                               \})}
  \CommentTok{\# do not need to verify linear predictors, this will be done in the}
  \CommentTok{\# .testProbabilities() function}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{exp}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{base\_hazard\_at\_t }\SpecialCharTok{*} \FunctionTok{exp}\NormalTok{(lin\_predictors))}
  
  \CommentTok{\# Ensure valid predictions}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(surv\_probabilities)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  
  \CommentTok{\# Bin and tally predicted probabilities}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.binData}\NormalTok{(surv\_probabilities, bin.boundaries)}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# No further manipulation of the result of .binData() is required}
\NormalTok{  result}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}survival::survreg\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survreg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&} \FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be numeric."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&}
        \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \DocumentationTok{\#\# Predict survival probabilities}
  
\NormalTok{  lin\_predictors }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(}\FunctionTok{predict}\NormalTok{(object, newdata, }\AttributeTok{type =} \StringTok{"lp"}\NormalTok{, ...),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain linear predictors."}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                               \})}
  \CommentTok{\# do not need to verify linear predictors, this will be done in the}
  \CommentTok{\# .testProbabilities() function}
                                   
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FloatTok{1.0} \SpecialCharTok{{-}}\NormalTok{ stats}\SpecialCharTok{::}\FunctionTok{pweibull}\NormalTok{(eval.time,}
                                              \AttributeTok{shape =} \FloatTok{1.0} \SpecialCharTok{/} \FunctionTok{exp}\NormalTok{(object}\SpecialCharTok{$}\NormalTok{scale),}
                                              \AttributeTok{scale =} \FunctionTok{exp}\NormalTok{(lin\_predictors))}
  \CommentTok{\# Ensure valid predictions}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(surv\_probabilities)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Bin and tally predicted probabilities}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.binData}\NormalTok{(surv\_probabilities, bin.boundaries)}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# No further manipulation of the result of .binData() is required}
\NormalTok{  result}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}SomaSurvival::fitSurvregnet\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries,}
\NormalTok{                                    lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&} \FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be numeric."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&}
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{),}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Convert to survreg object and use survreg method}
\NormalTok{  survreg\_object }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(SomaSurvival}\SpecialCharTok{::}\FunctionTok{convert2Survreg}\NormalTok{(object, lambda),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to convert \textasciigrave{}object\textasciigrave{} to \textasciigrave{}survreg\textasciigrave{}.}\SpecialCharTok{\textbackslash{}n\textbackslash{}t}\StringTok{"}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                             \})}
  
  \DocumentationTok{\#\#\# Task Implementation}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{survProbBins}\NormalTok{(survreg\_object, newdata, eval.time, bin.boundaries, ...)}

  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# No further manipulation of the result of .binData() is required}
\NormalTok{  result}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal function to test that probabilities are valid}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param predictions Numeric. The probabilities to test.}
\CommentTok{\#\textquotesingle{} @return Numeric. The probabilities with invalid values reset to NA\_real\_}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.testProbabilities }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(predictions) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}predictions\textasciigrave{} must be numeric."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(predictions) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(predictions) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(predictions) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(predictions) }\SpecialCharTok{!=}\NormalTok{ 0L}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# convert non{-}finite (NA, NaN, Inf) values to NA\_real\_}
  \CommentTok{\# convert values outside of [0, 1] to NA\_real\_}
\NormalTok{  bad\_values }\OtherTok{\textless{}{-}} \SpecialCharTok{!}\FunctionTok{is.finite}\NormalTok{(predictions) }\SpecialCharTok{|}\NormalTok{ predictions }\SpecialCharTok{\textless{}} \FloatTok{0.0} \SpecialCharTok{|}\NormalTok{ predictions }\SpecialCharTok{\textgreater{}} \FloatTok{1.0}
  \ControlFlowTok{if}\NormalTok{ ( }\FunctionTok{any}\NormalTok{(bad\_values) ) \{}
\NormalTok{    predictions[bad\_values] }\OtherTok{\textless{}{-}} \ConstantTok{NA\_real\_}
    \FunctionTok{message}\NormalTok{(}\FunctionTok{value}\NormalTok{(}\FunctionTok{sum}\NormalTok{(bad\_value)), }\StringTok{" invalid probabilities have been set to NA."}\NormalTok{)}
\NormalTok{  \}}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
\NormalTok{  predictions}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal function to perform binning}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Provided a vector of values and a vector of bin boundaries, identify the }
\CommentTok{\#\textquotesingle{}   bin in which each value falls and the total number of values in each bin.}
\CommentTok{\#\textquotesingle{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param values A numeric or numeric vector. The values to bin and tally.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The K+1 boundaries of K bins.}
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.binData }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(values, bin.boundaries) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}values\textasciigrave{} must be a non{-}empty, numeric vector."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(values) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(values) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(values) }\SpecialCharTok{\&\&}
        \FunctionTok{length}\NormalTok{(values) }\SpecialCharTok{!=}\NormalTok{ 0L,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector of length \textgreater{} 1."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(bin.boundaries),}
    \StringTok{"All values in \textasciigrave{}bin.boundaries\textasciigrave{} must be unique."} \OtherTok{=} 
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{==} \FunctionTok{length}\NormalTok{(}\FunctionTok{unique}\NormalTok{(bin.boundaries)),}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} cannot contain NA or NaN values."} \OtherTok{=} 
      \FunctionTok{all}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \SpecialCharTok{!}\FunctionTok{is.nan}\NormalTok{(bin.boundaries)),}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be in increasing order."} \OtherTok{=} \SpecialCharTok{!}\FunctionTok{is.unsorted}\NormalTok{(bin.boundaries),}
    \StringTok{"\textasciigrave{}values\textasciigrave{} must be finite and in range of \textasciigrave{}bin.boundaries\textasciigrave{}."} \OtherTok{=} 
      \FunctionTok{all}\NormalTok{(}\FunctionTok{is.finite}\NormalTok{(values)) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(values }\SpecialCharTok{\textgreater{}=} \FunctionTok{min}\NormalTok{(bin.boundaries)) }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(values }\SpecialCharTok{\textless{}=} \FunctionTok{max}\NormalTok{(bin.boundaries))}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Identify bin membership based on the provided probabilities}
  \CommentTok{\# returns k satisfying bin\_k \textless{}= x \textless{} bin\_\{k+1\}}
  \CommentTok{\# all.inside = TRUE sets anything that does not fall with the}
  \CommentTok{\# range of bin.boundaries to the nearest bin }
  \CommentTok{\# (i.e., 1 if x \textless{} bin\_1 or K if x \textgreater{} bin\_K)}
\NormalTok{  bins }\OtherTok{\textless{}{-}} \FunctionTok{findInterval}\NormalTok{(values, bin.boundaries, }\AttributeTok{all.inside =} \ConstantTok{TRUE}\NormalTok{)}
  
  \CommentTok{\# Tally the number of cases in each probability bin}
\NormalTok{  totals        }\OtherTok{\textless{}{-}} \FunctionTok{tabulate}\NormalTok{(bins)}
  \FunctionTok{names}\NormalTok{(totals) }\OtherTok{\textless{}{-}}\NormalTok{ 1L}\SpecialCharTok{:}\NormalTok{(}\FunctionTok{length}\NormalTok{(bins)}\SpecialCharTok{{-}}\NormalTok{1L)}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \FunctionTok{list}\NormalTok{(}\StringTok{"bin.boundaries"} \OtherTok{=}\NormalTok{ bin.boundaries, }
       \StringTok{"bin.id"}         \OtherTok{=}\NormalTok{ bins, }
       \StringTok{"totals"}         \OtherTok{=}\NormalTok{ totals)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

That's it! We have a fully implemented extendable tool for the requested task!

\hypertarget{extensions}{%
\subsection{Extensions}\label{extensions}}

If it is decided that this tool would be handy if a user could instead provide a numeric vector of predicted survival probabilities rather than a fitted model with new data, such an extension can be made by adding the following:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Function takes a user provided vector of survival probabilities or obtains}
\CommentTok{\#\textquotesingle{}   predicted survival probabilities from a provided fitted model and new data}
\CommentTok{\#\textquotesingle{}   and returns a vector of bin membership and the total number of cases in}
\CommentTok{\#\textquotesingle{}   each user{-}specified probability bin.}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @param object Fitted survival model or numeric vector. Fitted survival models}
\CommentTok{\#\textquotesingle{}   are currently limited to classes \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored. If \textasciigrave{}object\textasciigrave{} is numeric, this input is ignored.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{ }\FunctionTok{UseMethod}\NormalTok{(}\StringTok{"survProbBins"}\NormalTok{) \}}

\CommentTok{\#\textquotesingle{} S3 method for numeric vector objects}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.numeric }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We reserve testing of \textasciigrave{}object\textasciigrave{} for the testing utility function}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Ensure valid predictions}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(object)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  
  \CommentTok{\# Bin and tally predicted probabilities}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.binData}\NormalTok{(surv\_probabilities, bin.boundaries)}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# No further manipulation of the result of .binData() is required}
\NormalTok{  result}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Easy Peasy!!

\hypertarget{framework-and-utility-function-design-structure}{%
\section{Framework and Utility Function Design Structure}\label{framework-and-utility-function-design-structure}}

\hypertarget{usage-specification-1}{%
\subsection{Usage Specification}\label{usage-specification-1}}

The key components of this design are a main function detailing the procedure in terms of steps and utility functions to implement each step. An example outline of this design might be:

\begin{itemize}
\tightlist
\item
  A main function

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins(object,\ newdata,\ eval.time,\ bin.boundaries,\ lambda,\ ...)}

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Predict survival probabilities
    \item
      Call \texttt{.binData()} to bin and tally predicted survival probabilities
    \item
      Return \texttt{.binData()} value object
    \end{itemize}
  \end{itemize}
\item
  A utility function to predict survival probabilities

  \begin{itemize}
  \tightlist
  \item
    \texttt{.predictSurvivalProb(object,\ newdata,\ eval.time,\ ...)}

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Predict survival probabilities
    \item
      Call \texttt{.testProbabilities()}
    \item
      Return \texttt{.testProbabilities()} value object
    \end{itemize}
  \end{itemize}
\item
  A utility function to test validity of survival probabilities

  \begin{itemize}
  \tightlist
  \item
    \texttt{.testProbabilities(prediction)}

    \begin{itemize}
    \tightlist
    \item
      Ensure predicted probabilities are all finite and in {[}0,1{]}
    \end{itemize}
  \end{itemize}
\item
  A utility function to bin and tally predicted survival probabilities

  \begin{itemize}
  \tightlist
  \item
    \texttt{.binData(values,\ bin.boundaries)}

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Identify bin membership based on the provided probabilities
    \item
      Tally the number of cases in each probability bin
    \item
      Create a list containing the bin boundaries, bin membership, and totals
    \item
      Return list
    \end{itemize}
  \end{itemize}
\end{itemize}

Notice that two of our utility functions are identical to the internal common functions of the S3 based design. For brevity, we will not repeat the development of \texttt{.testProbabilities()} and \texttt{.binData()} in this section.

Next, we need to identify the steps in the procedure that are model type dependent. In this example, the step to predict survival probabilities is the only step that may vary across model types. Such dependence lends itself to an S3 structure. For example:

\begin{itemize}
\tightlist
\item
  A main function

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins(object,\ newdata,\ eval.time,\ bin.boundaries,\ lambda,\ ...)}

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Call \texttt{.predictSurvivalProb()} to estimate survival probabilities
    \item
      Call \texttt{.binData()} to bin and tally predicted survival probabilities
    \item
      Return \texttt{.binData()} value object
    \end{itemize}
  \end{itemize}
\item
  A utility method to predict survival probabilities

  \begin{itemize}
  \tightlist
  \item
    A generic method

    \begin{itemize}
    \tightlist
    \item
      .predictSurvivalProb(object, \ldots).
    \end{itemize}
  \item
    A default method

    \begin{itemize}
    \tightlist
    \item
      .predictSurvivalProb(object, \ldots).

      \begin{itemize}
      \tightlist
      \item
        Generate error indicating that object is not supported
      \end{itemize}
    \end{itemize}
  \item
    An extension method for coxph objects

    \begin{itemize}
    \tightlist
    \item
      .predictSurvivalProb(object, newdata, eval.time, \ldots).

      \begin{itemize}
      \tightlist
      \item
        Test validity of inputs
      \item
        Predict survival probabilities
      \item
        Call .testProbabilities()
      \end{itemize}
    \end{itemize}
  \item
    An extension method for survreg objects

    \begin{itemize}
    \tightlist
    \item
      .predictSurvivalProb(object, newdata, eval.time, \ldots).

      \begin{itemize}
      \tightlist
      \item
        Test validity of inputs
      \item
        Predict survival probabilities
      \item
        Call .testProbabilities()
      \end{itemize}
    \end{itemize}
  \item
    An extension method for survregnet objects

    \begin{itemize}
    \tightlist
    \item
      .predictSurvivalProb(object, newdata, eval.time, lambda, \ldots).

      \begin{itemize}
      \tightlist
      \item
        Test validity of inputs
      \item
        Call convert2Survreg() to convert object to a survreg object
      \item
        Call .predictSurvivalProb.survreg() using converted object.
      \end{itemize}
    \end{itemize}
  \end{itemize}
\item
  A utility function to test validity of survival probabilities

  \begin{itemize}
  \tightlist
  \item
    \texttt{.testProbabilities(prediction)}

    \begin{itemize}
    \tightlist
    \item
      Ensure predicted probabilities are all finite and in {[}0,1{]}
    \end{itemize}
  \end{itemize}
\item
  A utility function to bin and tally predicted survival probabilities

  \begin{itemize}
  \tightlist
  \item
    \texttt{.binData(values,\ bin.boundaries)}

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Identify bin membership based on the provided probabilities
    \item
      Tally the number of cases in each probability bin
    \item
      Create a list containing the bin boundaries, bin membership, and totals
    \item
      Return list
    \end{itemize}
  \end{itemize}
\end{itemize}

This design is very similar to the S3 based design. The key difference lies in where we place the model type dependency. For the S3 based design, that dependency rests with the task itself. The framework design shifts that dependency to the utility functions; specifically, the utility function that predicts the survival probability. An advantage of the framework design is that this functionality -- predict survival probabilities -- is now available to any other function in the package. In the S3 based design, this functionality is not accessible.

Because the functionality of predicting the survival probability is available throughout the package, it is most robust if it is developed to ensure that the returned predictions obey the expected behaviors of a survival probability. Specifically, survival probabilities must be in {[}0,1{]}; if they are not, an expected ``invalid'' value is returned (e.g., \texttt{NA\_real}). To make this utility function more robust should it be used elsewhere, it is a better design choice to do the testing within the prediction method. Thus, we chose to organize our design outline such that the ``test survival probabilities'' is performed in the prediction utility function itself rather than as a step in the main procedure.

\hypertarget{main-function}{%
\subsubsection{Main Function}\label{main-function}}

In the framework design, the main function, \texttt{survProbBins()}, sets up the general procedure for completing the task. That is, the steps required to perform the task are identified, but the details of each step are deferred to utility functions.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Function uses a fitted model and new data to estimate survival probabilities}
\CommentTok{\#\textquotesingle{}   and returns a vector of bin membership and the total number of cases in}
\CommentTok{\#\textquotesingle{}   each user{-}specified probability bin.}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat or data.frame. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data.}
\CommentTok{\#\textquotesingle{} @param eval.time Numeric. The time at which survival probabilities are to be}
\CommentTok{\#\textquotesingle{}   estimated.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The k+1 boundaries of the k}
\CommentTok{\#\textquotesingle{}   survival probability bins.}
\CommentTok{\#\textquotesingle{} @param lambda Numeric. The Elastic Net parameter of the model. }
\CommentTok{\#\textquotesingle{}   Required only if \textasciigrave{}object\textasciigrave{} is of class \textasciigrave{}survregnet\textasciigrave{}; ignored for all others.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, }
                         \AttributeTok{lambda =} \ConstantTok{NULL}\NormalTok{, ...) \{ }
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# Verify that \textasciigrave{}object\textasciigrave{}, \textasciigrave{}newdata\textasciigrave{}, \textasciigrave{}eval.time\textasciigrave{}, and \textasciigrave{}bin.boundaries\textasciigrave{} are provided}
  \CommentTok{\# Verify that object is a supported model type}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{} is a data.frame or soma\_adat}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{} contains the appropriate data}
  \CommentTok{\# Verify that \textasciigrave{}eval.time\textasciigrave{} is a positive scalar}
  \CommentTok{\# Verify that \textasciigrave{}bin.boundaries\textasciigrave{} is a numeric vector in [0, 1]}
  \CommentTok{\# Verify that \textasciigrave{}lambda\textasciigrave{} is NULL or a non{-}negative scalar}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Call \textasciigrave{}.predictSurvivalProb()\textasciigrave{} to estimate survival probabilities}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call \textasciigrave{}.binData()\textasciigrave{} to bin and tally predicted probabilities}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return \textasciigrave{}.binData()\textasciigrave{} value object}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Notice that in contrast to the S3 based framework, \textbf{ALL} of the inputs required by each model type must be provided as input. Here, \texttt{lambda} is an input regardless of the model type (though \texttt{NULL} is a perfectly acceptable value if \texttt{object} is not an Elastic Net model). We can circumvent this by dictating in the documentation that ``if \texttt{object} is Elastic Net, \texttt{...} must include the Elastic Net parameter, \texttt{lambda}.'' However, heavy reliance on the ellipsis for such one-off parameters could become confusing for the user.

\hypertarget{utility-functions}{%
\subsubsection{Utility Functions}\label{utility-functions}}

The implementation of the ``bin and tally the predicted probabilities'' and ``test the predicted survival probabilities'' will be identical to those developed under the S3 based design.

The details of the prediction step will depend on the model type, and thus it is a natural S3 method. Should more model types become supported, ideally we will only have to extend this method to include the new model type and make minor modifications to documentation and input testing in the main function.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Internal S3 Method for Estimating the Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} @return Numeric. The estimated survival probabilities with invalid or out of}
\CommentTok{\#\textquotesingle{}   range values reset to NA\_real\_.}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.predictSurvivalProb }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{ }
  \FunctionTok{UseMethod}\NormalTok{(}\StringTok{".predictSurvivalProb"}\NormalTok{) }
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.predictSurvivalProb.default }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{}
  \FunctionTok{stop}\NormalTok{(}\StringTok{"\textasciigrave{}.predictSurvivalProb()\textasciigrave{} does not yet support objects of class "}\NormalTok{,}
       \FunctionTok{value}\NormalTok{(}\FunctionTok{class}\NormalTok{(object))[1L], }\StringTok{"."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{\}}

\DocumentationTok{\#\#\# Individual methods for each of the classes we must support}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat or data.frame. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data.}
\CommentTok{\#\textquotesingle{} @param eval.time Numeric. The time at which survival probabilities are to be}
\CommentTok{\#\textquotesingle{}   estimated.}
\CommentTok{\#\textquotesingle{} @keywords internal}
\CommentTok{\#\textquotesingle{} @note inclusion of lambda as an input parameter in non{-}Elastic Net methods }
\CommentTok{\#\textquotesingle{}   ensures that it is not passed to the prediction method through the ellipsis}
\NormalTok{.predictSurvivalProb.coxph }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{} is a data.frame or soma\_adat}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{} contains the appropriate data}
  \CommentTok{\# Verify that \textasciigrave{}eval.time\textasciigrave{} is a positive scalar}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Predict survival probability}
  \CommentTok{\#}
  \CommentTok{\# Call .testProbabilities() to ensure valid predictions}
  
  \DocumentationTok{\#\#\# Result construction and testing}
  \CommentTok{\# Return predicted survival probability as an unnamed numeric vector}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @keywords internal}
\CommentTok{\#\textquotesingle{} @note inclusion of lambda as an input parameter in non{-}Elastic Net methods }
\CommentTok{\#\textquotesingle{}   ensures that it is not passed to the prediction method through the ellipsis}
\NormalTok{.predictSurvivalProb.survreg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{} is a data.frame or soma\_adat}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{} contains the appropriate data}
  \CommentTok{\# Verify that \textasciigrave{}eval.time\textasciigrave{} is a positive scalar}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Predict survival probability}
  \CommentTok{\#}
  \CommentTok{\# Call .testProbabilities() to ensure valid predictions}
  
  \DocumentationTok{\#\#\# Result construction and testing}
  \CommentTok{\# Return predicted survival probability as an unnamed numeric vector}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param lambda Numeric. The Elastic Net parameter, lambda, of the model. }
\CommentTok{\#\textquotesingle{} @keyword internal}
\NormalTok{.predictSurvivalProb.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, }
\NormalTok{                                            eval.time, lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{} is a data.frame or soma\_adat}
  \CommentTok{\# Verify that \textasciigrave{}newdata\textasciigrave{} contains the appropriate data}
  \CommentTok{\# Verify that \textasciigrave{}eval.time\textasciigrave{} is a positive scalar}
  \CommentTok{\# Verify that \textasciigrave{}lambda\textasciigrave{} is a non{-}negative scalar}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Convert to a survreg object}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# call .predictSurvivalProb.survreg() using the converted object}
  
  \DocumentationTok{\#\#\# Result construction and testing}
  \CommentTok{\# Return \textasciigrave{}.predictSurvivalProb()\textasciigrave{} value object}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{input-testing-2}{%
\subsection{Input Testing}\label{input-testing-2}}

Unlike the S3 based design, input \texttt{object} must be explicitly tested in the framework and utility function design to ensure that it supported.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Function uses a fitted model and new data to estimate survival probabilities}
\CommentTok{\#\textquotesingle{}   and returns a vector of bin membership and the total number of cases in}
\CommentTok{\#\textquotesingle{}   each user{-}specified probability bin.}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat or data.frame. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data.}
\CommentTok{\#\textquotesingle{} @param eval.time Numeric. The time at which survival probabilities are to be}
\CommentTok{\#\textquotesingle{}   estimated.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The k+1 boundaries of the k}
\CommentTok{\#\textquotesingle{}   survival probability bins.}
\CommentTok{\#\textquotesingle{} @param lambda Numeric or NULL. The Elastic Net parameter, lambda, of the model. }
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, }
                         \AttributeTok{lambda =} \ConstantTok{NULL}\NormalTok{, ...) \{ }
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}object\textasciigrave{} must be inherit from \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, or \textasciigrave{}survregnet\textasciigrave{}."} \OtherTok{=}
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(object) }\SpecialCharTok{\&\&} \FunctionTok{inherits}\NormalTok{(object, }\FunctionTok{c}\NormalTok{(}\StringTok{"coxph"}\NormalTok{, }\StringTok{"survreg"}\NormalTok{, }\StringTok{"survregnet"}\NormalTok{)),}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{),}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \FunctionTok{is.null}\NormalTok{(lambda) }\SpecialCharTok{||}\NormalTok{ (}\FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&} 
                            \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Call \textasciigrave{}.predictSurvivalProb()\textasciigrave{} to estimate survival probabilities}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call \textasciigrave{}.binData()\textasciigrave{} to bin and tally predicted probabilities}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return \textasciigrave{}.binData()\textasciigrave{} value object}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal S3 Method for Estimating the Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{} and their \textasciigrave{}stripped\_*\textasciigrave{} counterparts.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} @returns Numeric. The estimated survival probabilities with invalid or out of}
\CommentTok{\#\textquotesingle{}   range values reset to NA\_real\_.}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.predictSurvivalProb }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{ }
  \FunctionTok{UseMethod}\NormalTok{(}\StringTok{".predictSurvivalProb"}\NormalTok{) }
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.predictSurvivalProb.default }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{}
  \FunctionTok{stop}\NormalTok{(}\StringTok{"\textasciigrave{}.predictSurvivalProb()\textasciigrave{} does not yet support objects of class "}\NormalTok{,}
       \FunctionTok{value}\NormalTok{(}\FunctionTok{class}\NormalTok{(object))[1L], }\StringTok{"."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{\}}

\DocumentationTok{\#\#\# Individual methods for each of the classes we must support}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat or data.frame. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data.}
\CommentTok{\#\textquotesingle{} @param eval.time Numeric. The time at which survival probabilities are to be}
\CommentTok{\#\textquotesingle{}   estimated.}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.predictSurvivalProb.coxph }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementataion}
  \CommentTok{\# Predict survival probability}
  \CommentTok{\#}
  \CommentTok{\# Call .testProbabilities() to ensure valid predictions}
  
  \DocumentationTok{\#\#\# Result construction and testing}
  \CommentTok{\# Return predicted survival probability as an unnamed numeric vector}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{.predictSurvivalProb.survreg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Predict survival probability}
  \CommentTok{\#}
  \CommentTok{\# Call .testProbabilities() to ensure valid predictions}
  
  \DocumentationTok{\#\#\# Result construction and testing}
  \CommentTok{\# Return predicted survival probability as an unnamed numeric vector}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param lambda Numeric or NULL. The Elastic Net parameter, lambda, of the model. }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{.predictSurvivalProb.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, }
\NormalTok{                                            eval.time, lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&} 
      \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Call convert2survreg() to convert to a \textasciigrave{}survreg\textasciigrave{} object}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call .predictSurvivalProb.survreg() passing converted object}
  
  \DocumentationTok{\#\#\# Result construction and testing}
  \CommentTok{\# Return \textasciigrave{}.predictSurvivalProb.survreg()\textasciigrave{} value object}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{input-processing-2}{%
\subsection{Input Processing}\label{input-processing-2}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Function uses a fitted model and new data to estimate survival probabilities}
\CommentTok{\#\textquotesingle{}   and returns a vector of bin membership and the total number of cases in}
\CommentTok{\#\textquotesingle{}   each user{-}specified probability bin.}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat or data.frame. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data.}
\CommentTok{\#\textquotesingle{} @param eval.time Numeric. The time at which survival probabilities are to be}
\CommentTok{\#\textquotesingle{}   estimated.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The k+1 boundaries of the k}
\CommentTok{\#\textquotesingle{}   survival probability bins.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, }
                         \AttributeTok{lambda =} \ConstantTok{NULL}\NormalTok{, ...) \{ }
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}object\textasciigrave{} must be inherit from \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, or \textasciigrave{}survregnet\textasciigrave{}."} \OtherTok{=}
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(object) }\SpecialCharTok{\&\&} \FunctionTok{inherits}\NormalTok{(object, }\FunctionTok{c}\NormalTok{(}\StringTok{"coxph"}\NormalTok{, }\StringTok{"survreg"}\NormalTok{, }\StringTok{"survregnet"}\NormalTok{)),}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{),}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \FunctionTok{is.null}\NormalTok{(lambda) }\SpecialCharTok{||}\NormalTok{ (}\FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&}
                          \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Estimate survival probabilities}
\NormalTok{  predictions }\OtherTok{\textless{}{-}} \FunctionTok{.predictSurvivalProb}\NormalTok{(object, newdata, }\AttributeTok{lambda =}\NormalTok{ lambda, ...)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call \textasciigrave{}.binData()\textasciigrave{} to bin and tally predicted probabilities}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return \textasciigrave{}.binData()\textasciigrave{} value object}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal S3 Method for Estimating the Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{} and their \textasciigrave{}stripped\_*\textasciigrave{} counterparts.}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat or data.frame. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} @returns Numeric. The estimated survival probabilities with invalid or out of}
\CommentTok{\#\textquotesingle{}   range values reset to NA\_real\_.}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.predictSurvivalProb }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{ }
  \FunctionTok{UseMethod}\NormalTok{(}\StringTok{".predictSurvivalProb"}\NormalTok{) }
\NormalTok{\}}

\NormalTok{.predictSurvivalProb.default }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{}
  \FunctionTok{stop}\NormalTok{(}\StringTok{"\textasciigrave{}.predictSurvivalProb()\textasciigrave{} does not yet support objects of class "}\NormalTok{,}
       \FunctionTok{value}\NormalTok{(}\FunctionTok{class}\NormalTok{(object))[1L], }\StringTok{"."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{\}}

\DocumentationTok{\#\#\# Individual methods for each of the classes we must support}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\CommentTok{\#\textquotesingle{} Note including lambda as an input here eliminates it from being passed to}
\CommentTok{\#\textquotesingle{}   the prediction method through the ellipsis}
\NormalTok{.predictSurvivalProb.coxph }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Predict survival probability}
  \CommentTok{\#}
  \CommentTok{\# Call .testProbabilities() to ensure valid predictions}
  
  \DocumentationTok{\#\#\# Result construction and testing}
  \CommentTok{\# Return predicted survival probability as an unnamed numeric vector}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\CommentTok{\#\textquotesingle{} Note including lambda as an input here eliminates it from being passed to}
\CommentTok{\#\textquotesingle{}   the prediction method through the ellipsis}
\NormalTok{.predictSurvivalProb.survreg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, }
\NormalTok{                                         lambda, ...) \{}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Predict survival probability}
  \CommentTok{\#}
  \CommentTok{\# Call .testProbabilities() to ensure valid predictions}
  
  \DocumentationTok{\#\#\# Result construction and testing}
  \CommentTok{\# Return predicted survival probability as an unnamed numeric vector}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{.predictSurvivalProb.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, }
\NormalTok{                                            eval.time, lambda, ...) \{}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&} 
      \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Convert to survreg object and use survreg method}
\NormalTok{  survreg\_object }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(SomaSurvival}\SpecialCharTok{::}\FunctionTok{convert2Survreg}\NormalTok{(object, lambda),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to convert \textasciigrave{}object\textasciigrave{} to \textasciigrave{}survreg\textasciigrave{}.}\SpecialCharTok{\textbackslash{}n\textbackslash{}t}\StringTok{"}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                             \})}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Call \textasciigrave{}.predictSurvivalProb.survreg()\textasciigrave{} passing converted object}
  
  \DocumentationTok{\#\#\# Result construction and testing}
  \CommentTok{\# Return \textasciigrave{}.predictSurvivalProb.survreg()\textasciigrave{} value object}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{task-implementation-2}{%
\subsection{Task Implementation}\label{task-implementation-2}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Function uses a fitted model and new data to estimate survival probabilities}
\CommentTok{\#\textquotesingle{}   and returns a vector of bin membership and the total number of cases in}
\CommentTok{\#\textquotesingle{}   each user{-}specified probability bin.}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat or data.frame. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data.}
\CommentTok{\#\textquotesingle{} @param eval.time Numeric. The time at which survival probabilities are to be}
\CommentTok{\#\textquotesingle{}   estimated.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The k+1 boundaries of the k}
\CommentTok{\#\textquotesingle{}   survival probability bins.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, }
                         \AttributeTok{lambda =} \ConstantTok{NULL}\NormalTok{, ...) \{ }
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}object\textasciigrave{} must be inherit from \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, or \textasciigrave{}survregnet\textasciigrave{}."} \OtherTok{=}
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(object) }\SpecialCharTok{\&\&} \FunctionTok{inherits}\NormalTok{(object, }\FunctionTok{c}\NormalTok{(}\StringTok{"coxph"}\NormalTok{, }\StringTok{"survreg"}\NormalTok{, }\StringTok{"survregnet"}\NormalTok{)),}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{),}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \FunctionTok{is.null}\NormalTok{(lambda) }\SpecialCharTok{||}\NormalTok{ (}\FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&}
                            \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Process}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Estimate survival probabilities}
\NormalTok{  predictions }\OtherTok{\textless{}{-}} \FunctionTok{.predictSurvivalProb}\NormalTok{(object, newdata, }\AttributeTok{lambda =}\NormalTok{ lambda, ...)}
  
  \CommentTok{\# Bin and tally predicted probabilities}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.binData}\NormalTok{(predictions, bin.boundaries)}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# Return \textasciigrave{}.binData()\textasciigrave{} value object}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal S3 Method for Estimating the Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{} and their \textasciigrave{}stripped\_*\textasciigrave{} counterparts.}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat or data.frame. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} @returns Numeric. The estimated survival probabilities with invalid or out of}
\CommentTok{\#\textquotesingle{}   range values reset to NA\_real\_.}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.predictSurvivalProb }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{ }
  \FunctionTok{UseMethod}\NormalTok{(}\StringTok{".predictSurvivalProb"}\NormalTok{) }
\NormalTok{\}}

\NormalTok{.predictSurvivalProb.default }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{}
  \FunctionTok{stop}\NormalTok{(}\StringTok{"\textasciigrave{}.predictSurvivalProb()\textasciigrave{} does not yet support objects of class "}\NormalTok{,}
       \FunctionTok{value}\NormalTok{(}\FunctionTok{class}\NormalTok{(object))[1L], }\StringTok{"."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{\}}

\DocumentationTok{\#\#\# Individual methods for each of the classes we must support}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\CommentTok{\#\textquotesingle{} Note including lambda as an input here eliminates it from being passed to}
\CommentTok{\#\textquotesingle{}   the prediction method through the ellipsis}
\NormalTok{.predictSurvivalProb.coxph }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \DocumentationTok{\#\# Predict survival probabilities}
  
  \CommentTok{\# retrieve baseline hazard}
\NormalTok{  base\_hazard }\OtherTok{\textless{}{-}}\NormalTok{ survival}\SpecialCharTok{::}\FunctionTok{basehaz}\NormalTok{(object)}
  \CommentTok{\# identify time{-}point in baseline hazard nearest the specified evaluation time}
\NormalTok{  t\_idx       }\OtherTok{\textless{}{-}} \FunctionTok{which.min}\NormalTok{(}\FunctionTok{abs}\NormalTok{(eval.time }\SpecialCharTok{{-}}\NormalTok{ base\_hazard[, 2L]))}
  
\NormalTok{  base\_hazard\_at\_t }\OtherTok{\textless{}{-}}\NormalTok{ base\_hazard[t\_idx, 1L]}
  
  \CommentTok{\# ensure that baseline hazard is a valid value (not NA, NaN, Inf)}
  \ControlFlowTok{if}\NormalTok{ ( }\SpecialCharTok{!}\FunctionTok{is.finite}\NormalTok{(base\_hazard\_at\_t) ) \{}
    \FunctionTok{stop}\NormalTok{(}\StringTok{"Invalid baseline hazard "}\NormalTok{, }\FunctionTok{value}\NormalTok{(base\_hazard\_at\_t), }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{  \}}
  \FunctionTok{message}\NormalTok{(}\StringTok{"Survival probability evaluated at t = "}\NormalTok{, }\FunctionTok{value}\NormalTok{(base\_hazard[t\_idx, 2L]))}

  \CommentTok{\# get linear predictors for newdata}
\NormalTok{  lin\_predictors }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(}\FunctionTok{predict}\NormalTok{(object, newdata, }\AttributeTok{type =} \StringTok{"lp"}\NormalTok{, ...),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain linear predictors."}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                               \})}
  \CommentTok{\# do not need to verify linear predictors, this will be done in the}
  \CommentTok{\# .testProbabilities() function}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{exp}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{base\_hazard\_at\_t }\SpecialCharTok{*} \FunctionTok{exp}\NormalTok{(lin\_predictors))}
  
  \CommentTok{\# Ensure valid predictions}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(surv\_probabilities)}
  
  \DocumentationTok{\#\#\# Result construction and testing}
  \CommentTok{\# Return predicted survival probability as an unnamed numeric vector}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\CommentTok{\#\textquotesingle{} Note including lambda as an input here eliminates it from being passed to}
\CommentTok{\#\textquotesingle{}   the prediction method through the ellipsis}
\NormalTok{.predictSurvivalProb.survreg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, }
\NormalTok{                                         lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \DocumentationTok{\#\# Predict survival probabilities}
  
\NormalTok{  lin\_predictors }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(}\FunctionTok{predict}\NormalTok{(object, newdata, }\AttributeTok{type =} \StringTok{"lp"}\NormalTok{, ...),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain linear predictors."}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                               \})}
  \CommentTok{\# do not need to verify linear predictors, this will be done in the}
  \CommentTok{\# .testProbabilities() function}
                                   
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FloatTok{1.0} \SpecialCharTok{{-}}\NormalTok{ stats}\SpecialCharTok{::}\FunctionTok{pweibull}\NormalTok{(eval.time,}
                                              \AttributeTok{shape =} \FloatTok{1.0} \SpecialCharTok{/} \FunctionTok{exp}\NormalTok{(object}\SpecialCharTok{$}\NormalTok{scale),}
                                              \AttributeTok{scale =} \FunctionTok{exp}\NormalTok{(lin\_predictors))}
  \CommentTok{\# Ensure valid predictions}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(surv\_probabilities)}
  
  \DocumentationTok{\#\#\# Result construction and testing}
  \CommentTok{\# Return predicted survival probability as an unnamed numeric vector}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{.predictSurvivalProb.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, }
\NormalTok{                                            eval.time, lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&} 
      \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Convert to survreg object and use survreg method}
\NormalTok{  survreg\_object }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(SomaSurvival}\SpecialCharTok{::}\FunctionTok{convert2Survreg}\NormalTok{(object, lambda),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to convert \textasciigrave{}object\textasciigrave{} to \textasciigrave{}survreg\textasciigrave{}.}\SpecialCharTok{\textbackslash{}n\textbackslash{}t}\StringTok{"}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                             \})}
  
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.predictSurvivalProb}\NormalTok{(survreg\_object, newdata, eval.time, ...)}
  
  \DocumentationTok{\#\#\# Result construction and testing}
  \CommentTok{\# Return \textasciigrave{}.predictSurvivalProb.survreg()\textasciigrave{} value object}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{results-construction-and-testing-1}{%
\subsection{Results Construction and Testing}\label{results-construction-and-testing-1}}

For our example, there are no additional processing steps required for the result; \texttt{.binData()} created the expected list.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Function uses a fitted model and new data to estimate survival probabilities}
\CommentTok{\#\textquotesingle{}   and returns a vector of bin membership and the total number of cases in}
\CommentTok{\#\textquotesingle{}   each user{-}specified probability bin.}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat or data.frame. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data.}
\CommentTok{\#\textquotesingle{} @param eval.time Numeric. The time at which survival probabilities are to be}
\CommentTok{\#\textquotesingle{}   estimated.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The k+1 boundaries of the k}
\CommentTok{\#\textquotesingle{}   survival probability bins.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, }
                         \AttributeTok{lambda =} \ConstantTok{NULL}\NormalTok{, ...) \{ }
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}object\textasciigrave{} must be inherit from \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, or \textasciigrave{}survregnet\textasciigrave{}."} \OtherTok{=}
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(object) }\SpecialCharTok{\&\&} \FunctionTok{inherits}\NormalTok{(object, }\FunctionTok{c}\NormalTok{(}\StringTok{"coxph"}\NormalTok{, }\StringTok{"survreg"}\NormalTok{, }\StringTok{"survregnet"}\NormalTok{)),}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{),}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \FunctionTok{is.null}\NormalTok{(lambda) }\SpecialCharTok{||}\NormalTok{ (}\FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&}
                            \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Process}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Estimate survival probabilities}
\NormalTok{  predictions }\OtherTok{\textless{}{-}} \FunctionTok{.predictSurvivalProb}\NormalTok{(object, newdata, }\AttributeTok{lambda =}\NormalTok{ lambda, ...)}
  
  \CommentTok{\# Bin and tally predicted probabilities}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.binData}\NormalTok{(predictions, bin.boundaries)}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# No further manipulation of the result of .binData() is required}
\NormalTok{  result}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal S3 Method for Estimating the Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{} and their \textasciigrave{}stripped\_*\textasciigrave{} counterparts.}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat or data.frame. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} @returns Numeric. The estimated survival probabilities with invalid or out of}
\CommentTok{\#\textquotesingle{}   range values reset to NA\_real\_.}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.predictSurvivalProb }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{ }
  \FunctionTok{UseMethod}\NormalTok{(}\StringTok{".predictSurvivalProb"}\NormalTok{) }
\NormalTok{\}}

\NormalTok{.predictSurvivalProb.default }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{}
  \FunctionTok{stop}\NormalTok{(}\StringTok{"\textasciigrave{}.predictSurvivalProb()\textasciigrave{} does not yet support objects of class "}\NormalTok{,}
       \FunctionTok{value}\NormalTok{(}\FunctionTok{class}\NormalTok{(object))[1L], }\StringTok{"."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{\}}

\DocumentationTok{\#\#\# Individual methods for each of the classes we must support}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\CommentTok{\#\textquotesingle{} Note including lambda as an input here eliminates it from being passed to}
\CommentTok{\#\textquotesingle{}   the prediction method through the ellipsis}
\NormalTok{.predictSurvivalProb.coxph }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \DocumentationTok{\#\# Predict survival probabilities}
  
  \CommentTok{\# retrieve baseline hazard}
\NormalTok{  base\_hazard }\OtherTok{\textless{}{-}}\NormalTok{ survival}\SpecialCharTok{::}\FunctionTok{basehaz}\NormalTok{(object)}
  \CommentTok{\# identify time{-}point in baseline hazard nearest the specified evaluation time}
\NormalTok{  t\_idx       }\OtherTok{\textless{}{-}} \FunctionTok{which.min}\NormalTok{(}\FunctionTok{abs}\NormalTok{(eval.time }\SpecialCharTok{{-}}\NormalTok{ base\_hazard[, 2L]))}
  
\NormalTok{  base\_hazard\_at\_t }\OtherTok{\textless{}{-}}\NormalTok{ base\_hazard[t\_idx, 1L]}
  
  \CommentTok{\# ensure that baseline hazard is a valid value (not NA, NaN, Inf)}
  \ControlFlowTok{if}\NormalTok{ ( }\SpecialCharTok{!}\FunctionTok{is.finite}\NormalTok{(base\_hazard\_at\_t) ) \{}
    \FunctionTok{stop}\NormalTok{(}\StringTok{"Invalid baseline hazard "}\NormalTok{, }\FunctionTok{value}\NormalTok{(base\_hazard\_at\_t), }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{  \}}
  \FunctionTok{message}\NormalTok{(}\StringTok{"Survival probability evaluated at t = "}\NormalTok{, }\FunctionTok{value}\NormalTok{(base\_hazard[t\_idx, 2L]))}

  \CommentTok{\# get linear predictors for newdata}
\NormalTok{  lin\_predictors }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(}\FunctionTok{predict}\NormalTok{(object, newdata, }\AttributeTok{type =} \StringTok{"lp"}\NormalTok{, ...),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain linear predictors."}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                               \})}
  \CommentTok{\# do not need to verify linear predictors, this will be done in the}
  \CommentTok{\# .testProbabilities() function}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{exp}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{base\_hazard\_at\_t }\SpecialCharTok{*} \FunctionTok{exp}\NormalTok{(lin\_predictors))}
  
  \CommentTok{\# Ensure valid predictions}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(surv\_probabilities)}
  
  \DocumentationTok{\#\#\# Result construction and testing}
  \FunctionTok{unname}\NormalTok{(result)}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\CommentTok{\#\textquotesingle{} Note including lambda as an input here eliminates it from being passed to}
\CommentTok{\#\textquotesingle{}   the prediction method through the ellipsis}
\NormalTok{.predictSurvivalProb.survreg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, }
\NormalTok{                                         lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \DocumentationTok{\#\# Predict survival probabilities}
  
\NormalTok{  lin\_predictors }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(}\FunctionTok{predict}\NormalTok{(object, newdata, }\AttributeTok{type =} \StringTok{"lp"}\NormalTok{, ...),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain linear predictors."}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                               \})}
  \CommentTok{\# do not need to verify linear predictors, this will be done in the}
  \CommentTok{\# .testProbabilities() function}
                                   
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FloatTok{1.0} \SpecialCharTok{{-}}\NormalTok{ stats}\SpecialCharTok{::}\FunctionTok{pweibull}\NormalTok{(eval.time,}
                                              \AttributeTok{shape =} \FloatTok{1.0} \SpecialCharTok{/} \FunctionTok{exp}\NormalTok{(object}\SpecialCharTok{$}\NormalTok{scale),}
                                              \AttributeTok{scale =} \FunctionTok{exp}\NormalTok{(lin\_predictors))}
  \CommentTok{\# Ensure valid predictions}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(surv\_probabilities)}
  
  \DocumentationTok{\#\#\# Result construction and testing}
  \FunctionTok{unname}\NormalTok{(result)}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{.predictSurvivalProb.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, }
\NormalTok{                                            eval.time, lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&} 
      \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Convert to survreg object and use survreg method}
\NormalTok{  survreg\_object }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(SomaSurvival}\SpecialCharTok{::}\FunctionTok{convert2Survreg}\NormalTok{(object, lambda),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to convert \textasciigrave{}object\textasciigrave{} to \textasciigrave{}survreg\textasciigrave{}.}\SpecialCharTok{\textbackslash{}n\textbackslash{}t}\StringTok{"}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                             \})}
  
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.predictSurvivalProb}\NormalTok{(survreg\_object, newdata, eval.time, ...)}
  
  \DocumentationTok{\#\#\# Result construction and testing}
\NormalTok{  result}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{extensions-1}{%
\subsection{Extensions}\label{extensions-1}}

If it is decided that this tool would be handy if a user could instead provide a numeric vector of predicted survival probabilities rather than a fitted model, there are a few options available for this extension. First, the step of the main function responsible for predicting the survival probability could be wrapped in an \texttt{if/else} statement.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Function takes a user provided vector of survival probabilities or obtains}
\CommentTok{\#\textquotesingle{}   predicted survival probabilities from a provided fitted model and new data}
\CommentTok{\#\textquotesingle{}   and returns a vector of bin membership and the total number of cases in}
\CommentTok{\#\textquotesingle{}   each user{-}specified probability bin.}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @param object Fitted survival model or numeric vector. Survival models are }
\CommentTok{\#\textquotesingle{}   currently limited to classes \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat, data.frame, or NULL. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data. If NULL, \textasciigrave{}object\textasciigrave{} must be a numeric vector.}
\CommentTok{\#\textquotesingle{} @param eval.time Numeric. The time at which survival probabilities are to be}
\CommentTok{\#\textquotesingle{}   estimated.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The k+1 boundaries of the k}
\CommentTok{\#\textquotesingle{}   survival probability bins.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored. If \textasciigrave{}object\textasciigrave{} is numeric, input is ignored.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, }\AttributeTok{newdata =} \ConstantTok{NULL}\NormalTok{, eval.time, bin.boundaries, }
                         \AttributeTok{lambda =} \ConstantTok{NULL}\NormalTok{, ...) \{ }
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}object\textasciigrave{} must be inherit from \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}numeric\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, or \textasciigrave{}survregnet\textasciigrave{}."} \OtherTok{=}
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(object) }\SpecialCharTok{\&\&} \FunctionTok{inherits}\NormalTok{(object, }\FunctionTok{c}\NormalTok{(}\StringTok{"coxph"}\NormalTok{, }\StringTok{"numeric"}\NormalTok{, }\StringTok{"survreg"}\NormalTok{, }\StringTok{"survregnet"}\NormalTok{)),}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{),}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \FunctionTok{is.null}\NormalTok{(lambda) }\SpecialCharTok{||}\NormalTok{ (}\FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&}
                            \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Process}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Estimate survival probabilities}
  \ControlFlowTok{if}\NormalTok{ ( }\FunctionTok{is.numeric}\NormalTok{(object) ) \{}
    \ControlFlowTok{if}\NormalTok{ ( }\FunctionTok{is.vector}\NormalTok{(object) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(object) }\SpecialCharTok{!=}\NormalTok{ 0L ) \{}
\NormalTok{      predictions }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(object)}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \FunctionTok{stop}\NormalTok{(}\StringTok{"\textasciigrave{}object\textasciigrave{} must be a non{-}empty numeric vector if predictions are provided"}\NormalTok{,}
           \AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    predictions }\OtherTok{\textless{}{-}} \FunctionTok{.predictSurvivalProb}\NormalTok{(object, newdata, }\AttributeTok{lambda =}\NormalTok{ lambda, ...)}
\NormalTok{  \}}
  
  \CommentTok{\# Bin and tally predicted probabilities}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.binData}\NormalTok{(predictions, bin.boundaries)}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# No further manipulation of the result of .binData() is required}
\NormalTok{  result}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Notice that this extension required some modification to our usage statement (\texttt{newdata} can now be \texttt{NULL}) as well as additional options for the input testing of \texttt{object} and \texttt{newdata}. This choice may not be ideal as should the supported types for \texttt{object} be extended to other non-model type objects, additional layering of the \texttt{if/else} would be necessary, which can become cumbersome!

Another solution is to extend the prediction method. We still need to make some adjustments to the usage of the main function.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Function takes a user provided vector of survival probabilities or obtains}
\CommentTok{\#\textquotesingle{}   predicted survival probabilities from a provided fitted model and new data}
\CommentTok{\#\textquotesingle{}   and returns a vector of bin membership and the total number of cases in}
\CommentTok{\#\textquotesingle{}   each user{-}specified probability bin.}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @param object Fitted survival model or numeric vector. Survival models are }
\CommentTok{\#\textquotesingle{}   currently limited to classes \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat, data.frame, or NULL. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data. If NULL, \textasciigrave{}object\textasciigrave{} must be a numeric vector.}
\CommentTok{\#\textquotesingle{} @param eval.time Numeric. The time at which survival probabilities are to be}
\CommentTok{\#\textquotesingle{}   estimated.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The k+1 boundaries of the k}
\CommentTok{\#\textquotesingle{}   survival probability bins.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored. If \textasciigrave{}object\textasciigrave{} is numeric, input is ignored.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, }\AttributeTok{newdata =} \ConstantTok{NULL}\NormalTok{, eval.time, bin.boundaries, }
                         \AttributeTok{lambda =} \ConstantTok{NULL}\NormalTok{, ...) \{ }
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}object\textasciigrave{} must be inherit from \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}numeric\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, or \textasciigrave{}survregnet\textasciigrave{}."} \OtherTok{=}
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(object) }\SpecialCharTok{\&\&} \FunctionTok{inherits}\NormalTok{(object, }\FunctionTok{c}\NormalTok{(}\StringTok{"coxph"}\NormalTok{, }\StringTok{"numeric"}\NormalTok{, }\StringTok{"survreg"}\NormalTok{, }\StringTok{"survregnet"}\NormalTok{)),}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{),}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \FunctionTok{is.null}\NormalTok{(lambda) }\SpecialCharTok{||}\NormalTok{ (}\FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&}
                            \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Process}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Estimate survival probabilities}
\NormalTok{  predictions }\OtherTok{\textless{}{-}} \FunctionTok{.predictSurvivalProb}\NormalTok{(object, newdata, }\AttributeTok{lambda =}\NormalTok{ lambda, ...)}

  \CommentTok{\# Bin and tally predicted probabilities}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.binData}\NormalTok{(predictions, bin.boundaries)}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# No further manipulation of the result of .binData() is required}
\NormalTok{  result}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{.predictSurvivalProb.numeric }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{}
  
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}object\textasciigrave{} must be a non{-}empty numeric vector if predictions are provided"} \OtherTok{=}
      \FunctionTok{is.vector}\NormalTok{(object) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(object) }\SpecialCharTok{!=}\NormalTok{ 0L}
\NormalTok{  )}
  
  \CommentTok{\# Ensure valid predictions}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(object)}
  
  \DocumentationTok{\#\#\# Result construction and testing}
\NormalTok{  result}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This choice may seem odd given that one is not actually ``predicting a survival function'' but rather processing a provided prediction. Further, one must be careful that this extension of the prediction function does not have unintended consequences for other functions that might call \texttt{.predictSurvivalProb()}. However, if proper input testing is implemented in the downstream function, this is not a significant concern.

\hypertarget{key-design-differences}{%
\section{Key Design Differences}\label{key-design-differences}}

\begin{itemize}
\tightlist
\item
  S3 Based Design

  \begin{itemize}
  \tightlist
  \item
    Pros

    \begin{itemize}
    \tightlist
    \item
      \textbf{Extension to new model types does not risk changes to existing functionality.}
      To extend the tool to new model types, a developer need only create a new function \texttt{survProbBins.newType()}, which would need to execute the verification of input, obtain the predicted survival probabilities, and call the bin/tally method. There is little possibility that the added function will impact the execution of or results from the existing methods.
    \item
      \textbf{Freedom in type-specific input arguments.}
      Because each method \emph{must} contain only the dispatching argument (in our example, \texttt{object}), each method can declare its own required inputs. In our example, the Elastic Net parameter \texttt{lambda}, is an input only for the Elastic Net model type.
    \item
      \textbf{More familiar to our users.}
      This is the primary design choice of the \texttt{somaverse} -- our users are accustomed to its structure, which could make debugging for them easier.
    \end{itemize}
  \item
    Cons

    \begin{itemize}
    \tightlist
    \item
      \textbf{Steps implemented within the individuals methods are not available to other functions.}
      In our example, the prediction step is hidden within the \texttt{survProbBins.*()} functions, i.e., it is not returned as output so this predicted value cannot be accessed by a another function in the package. It is not unreasonable to imagine that a method to predict survival probabilities for a supported model would be useful elsewhere, but under the current design, it would need to be re-implemented. (More on this later.)
    \item
      \textbf{Full coverage of unit tests can be difficult.}
      If multiple steps of the procedure are implemented in each individual method, it can be challenging to get strong coverage in unit tests.
    \item
      \textbf{Procedure evolution.}
      In the absence of a single function specifying the steps required to complete the task, it is possible for subtle differences to arise in the procedure across model types.
    \end{itemize}
  \end{itemize}
\item
  Framework and Utility Functions Design

  \begin{itemize}
  \tightlist
  \item
    Pros

    \begin{itemize}
    \tightlist
    \item
      \textbf{Main function highlights the \emph{structure} of the solution rather than the details required for each model type.}
      This structure provides ``sign posts'' that can make developing unit tests easier and provides future developers the explicit steps expected to accomplish the task.
    \item
      \textbf{Each step of the procedure can be individually unit tested.}
      Each function can be robustly unit tested to ensure that it matches the developers expectations. A key aspect of this design is that utility functions should be developed such that very little is ``hidden'' from unit tests.
    \item
      \textbf{All utility functions are available to all other functions in the package.}
      In our example, \texttt{.predictProbSurv()} can be used elsewhere if needed without further development or testing.
    \item
      \textbf{Extensions to utility functions become immediately available to other functions.}
      This can expedite extending multiple methods to new model types.
    \end{itemize}
  \item
    Cons

    \begin{itemize}
    \tightlist
    \item
      \textbf{Extension to new model types may require changes to existing functions.}
      For utility steps that are implemented as functions, developers must ensure that new functionality does not impact previously written code.
    \item
      \textbf{Extension to new model types may not be intuitive or might require cumbersome if/else structures.}
      In our example we illustrated how to extend to a numeric vector of predictions. The utility function \texttt{.predictSurvalProb()} does not necessarily ``make sense'' when provided a vector of predictions.
    \item
      \textbf{Bloated input structure.}
      Because inputs are shared across all model types, we lose the freedom to add or remove inputs for each model type. For example, because we support Elastic Net models, \texttt{lambda} must be provided as an input no matter the model type (though \texttt{NULL} is a perfectly acceptable value for non-Elastic Net models). This restriction can introduce confusion for users that must be clearly addressed in the documentation. Further, adding extensions might requiring adding additional input arguments or modifying default values - all of which can have unexpected consequences downstream if not done carefully.
    \end{itemize}
  \end{itemize}
\end{itemize}

\hypertarget{blended-design}{%
\section{Blended Design}\label{blended-design}}

The implementations that we chose above were meant to highlight the key differences between these two general design choices. We can address some of the disadvantages of the each method by blending the two designs. Specifically, we can move the survival probability prediction and testing steps of the S3 based design to its own individual S3 utility method, as was implemented in the framework design.

\begin{itemize}
\tightlist
\item
  A generic method

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins(object,\ ...)}.
  \end{itemize}
\item
  A default method

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.default(object,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Generate error indicating that \texttt{object} is not supported
    \end{itemize}
  \end{itemize}
\item
  An extension method for \texttt{coxph} objects

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.coxph(object,\ newdata,\ eval.time,\ bin.boundaries,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Call \texttt{.predictSurvivalProb()}
    \item
      Call \texttt{.binData()}
    \item
      Return \texttt{.binData()} value object
    \end{itemize}
  \end{itemize}
\item
  An extension method for \texttt{survreg} objects

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.survreg(object,\ newdata,\ eval.time,\ bin.boundaries,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Call \texttt{.predictSurvivalProb()}
    \item
      Call \texttt{.binData()}
    \item
      Return \texttt{.binData()} value object
    \end{itemize}
  \end{itemize}
\item
  An extension method for \texttt{survregnet} objects

  \begin{itemize}
  \tightlist
  \item
    \texttt{survProbBins.survregnet(object,\ newdata,\ eval.time,\ bin.boundaries,\ lambda,\ ...)}.

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Call \texttt{.predictSurvivalProb()}
    \item
      Call \texttt{.binData()}
    \item
      Return \texttt{.binData()} value object
    \end{itemize}
  \end{itemize}
\item
  A utility method to predict survival probabilities

  \begin{itemize}
  \tightlist
  \item
    A generic method

    \begin{itemize}
    \tightlist
    \item
      \texttt{.predictSurvivalProb(object,\ ...)}.
    \end{itemize}
  \item
    A default method

    \begin{itemize}
    \tightlist
    \item
      \texttt{.predictSurvivalProb(object,\ ...)}.

      \begin{itemize}
      \tightlist
      \item
        Generate error indicating that \texttt{object} is not supported
      \end{itemize}
    \end{itemize}
  \item
    An extension method for \texttt{coxph} objects

    \begin{itemize}
    \tightlist
    \item
      \texttt{.predictSurvivalProb(object,\ newdata,\ eval.time,\ ...)}.

      \begin{itemize}
      \tightlist
      \item
        Test validity of inputs
      \item
        Predict survival probabilities
      \item
        Call \texttt{.testProbabilities()}
      \item
        Return \texttt{.testProbabilities()} value object
      \end{itemize}
    \end{itemize}
  \item
    An extension method for \texttt{survreg} objects

    \begin{itemize}
    \tightlist
    \item
      \texttt{.predictSurvivalProb(object,\ newdata,\ eval.time,\ ...)}.

      \begin{itemize}
      \tightlist
      \item
        Test validity of inputs
      \item
        Predict survival probabilities
      \item
        Call \texttt{.testProbabilities()}
      \item
        Return \texttt{.testProbabilities()} value object
      \end{itemize}
    \end{itemize}
  \item
    An extension method for \texttt{survregnet} objects

    \begin{itemize}
    \tightlist
    \item
      \texttt{.predictSurvivalProb(object,\ newdata,\ eval.time,\ lambda,\ ...)}.

      \begin{itemize}
      \tightlist
      \item
        Test validity of inputs
      \item
        Call \texttt{convert2Survreg()} to convert \texttt{object} to a \texttt{survreg} object
      \item
        Call \texttt{.predictSurvivalProb.survreg()} using converted object.
      \item
        Return \texttt{.predictSurvivalProb.survreg()} value object
      \end{itemize}
    \end{itemize}
  \end{itemize}
\item
  An internal function for binning and tallying a vector of values

  \begin{itemize}
  \tightlist
  \item
    \texttt{.binData(values,\ bin.boundaries)}.

    \begin{itemize}
    \tightlist
    \item
      Test validity of inputs
    \item
      Identify bin membership based on the provided probabilities
    \item
      Tally the number of cases in each probability bin
    \item
      Create a list containing the bin boundaries, bin membership, and totals
    \item
      Return list
    \end{itemize}
  \end{itemize}
\item
  An internal function for testing validity of survival probabilities

  \begin{itemize}
  \tightlist
  \item
    \texttt{.testProbabilities(predictions)}.

    \begin{itemize}
    \tightlist
    \item
      Ensure predicted probabilities are all finite and in {[}0,1{]}
    \end{itemize}
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Bin Predicted Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Function uses a fitted model and new data to estimate survival probabilities}
\CommentTok{\#\textquotesingle{}   and returns a vector of bin membership and the total number of cases in}
\CommentTok{\#\textquotesingle{}   each user{-}specified probability bin.}
\CommentTok{\#\textquotesingle{}   }
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{}.}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat or data.frame. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data.}
\CommentTok{\#\textquotesingle{} @param eval.time Numeric. The time at which survival probabilities are to be}
\CommentTok{\#\textquotesingle{}   estimated.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The k+1 boundaries of the k}
\CommentTok{\#\textquotesingle{}   survival probability bins.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{ }\FunctionTok{UseMethod}\NormalTok{(}\StringTok{"survProbBins"}\NormalTok{) \}}

\CommentTok{\#\textquotesingle{} S3 default method {-}{-} error only}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.default }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{}
  \FunctionTok{stop}\NormalTok{(}\StringTok{"\textasciigrave{}survProbBins()\textasciigrave{} does not yet support objects of class "}\NormalTok{,}
       \FunctionTok{value}\NormalTok{(}\FunctionTok{class}\NormalTok{(object))[1L], }\StringTok{"."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{\}}

\DocumentationTok{\#\#\# Individual methods for each of the classes we must support}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}survival::coxph()\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.coxph }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Predict survival probabilities}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{.predictSurvivalProb}\NormalTok{(object, newdata, ...)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Bin and tally predicted probabilities}
  \FunctionTok{.binData}\NormalTok{(surv\_probabilities, bin.boundaries)}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}survival::survreg\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survreg }\OtherTok{\textless{}{-}}\NormalTok{ survProbBins.coxph}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}SomaSurvival::fitSurvregnet\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries,}
\NormalTok{                                    lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&} 
      \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Predict survival probabilities}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{.predictSurvivalProb}\NormalTok{(object, newdata, }\AttributeTok{lambda =}\NormalTok{ lambda, ...)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Bin and tally predicted probabilities}
  \FunctionTok{.binData}\NormalTok{(surv\_probabilities, bin.boundaries)}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal S3 Method for Estimating the Survival Probabilities}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param object Fitted survival model. Currently limited to classes}
\CommentTok{\#\textquotesingle{}   \textasciigrave{}coxph\textasciigrave{}, \textasciigrave{}survreg\textasciigrave{}, and \textasciigrave{}survregnet\textasciigrave{} and their \textasciigrave{}stripped\_*\textasciigrave{} counterparts.}
\CommentTok{\#\textquotesingle{} @param newdata soma\_adat or data.frame. The model covariates, times, and}
\CommentTok{\#\textquotesingle{}   status data.}
\CommentTok{\#\textquotesingle{} @param ... Optional arguments passed to the \textasciigrave{}predict.*\textasciigrave{} method. Note that}
\CommentTok{\#\textquotesingle{}   input \textasciigrave{}type\textasciigrave{} will be ignored.}
\CommentTok{\#\textquotesingle{}}
\CommentTok{\#\textquotesingle{} @returns Numeric. The estimated survival probabilities with invalid or out of}
\CommentTok{\#\textquotesingle{}   range values reset to NA\_real\_.}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.predictSurvivalProb }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{ }
  \FunctionTok{UseMethod}\NormalTok{(}\StringTok{".predictSurvivalProb"}\NormalTok{) }
\NormalTok{\}}

\NormalTok{.predictSurvivalProb.default }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, ...) \{}
  \FunctionTok{stop}\NormalTok{(}\StringTok{"\textasciigrave{}.predictSurvivalProb()\textasciigrave{} does not yet support objects of class "}\NormalTok{,}
       \FunctionTok{value}\NormalTok{(}\FunctionTok{class}\NormalTok{(object))[1L], }\StringTok{"."}\NormalTok{, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{\}}

\DocumentationTok{\#\#\# Individual methods for each of the classes we must support}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\CommentTok{\#\textquotesingle{} Note including lambda as an input here eliminates it from being passed to}
\CommentTok{\#\textquotesingle{}   the prediction method through the ellipsis}
\NormalTok{.predictSurvivalProb.coxph }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \DocumentationTok{\#\# Predict survival probabilities}
  
  \CommentTok{\# retrieve baseline hazard}
\NormalTok{  base\_hazard }\OtherTok{\textless{}{-}}\NormalTok{ survival}\SpecialCharTok{::}\FunctionTok{basehaz}\NormalTok{(object)}
  \CommentTok{\# identify time{-}point in baseline hazard nearest the specified evaluation time}
\NormalTok{  t\_idx       }\OtherTok{\textless{}{-}} \FunctionTok{which.min}\NormalTok{(}\FunctionTok{abs}\NormalTok{(eval.time }\SpecialCharTok{{-}}\NormalTok{ base\_hazard[, 2L]))}
  
  \CommentTok{\# ensure that baseline hazard is a valid value (not NA, NaN, Inf)}
  \ControlFlowTok{if}\NormalTok{ ( }\SpecialCharTok{!}\FunctionTok{is.finite}\NormalTok{(base\_hazard[t\_idx, 1L]) ) \{}
    \FunctionTok{stop}\NormalTok{(}\StringTok{"Invalid baseline hazard "}\NormalTok{, }\FunctionTok{value}\NormalTok{(base\_hazard[t\_idx, 1L]), }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{  \}}
  \FunctionTok{message}\NormalTok{(}\StringTok{"Survival probability evaluated at t = "}\NormalTok{, }\FunctionTok{value}\NormalTok{(base\_hazard[t\_idx, 2L]))}

  \CommentTok{\# get linear predictors for newdata}
\NormalTok{  lin\_predictors }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(}\FunctionTok{predict}\NormalTok{(object, newdata, }\AttributeTok{type =} \StringTok{"lp"}\NormalTok{, ...),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain linear predictors."}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                               \})}
  \CommentTok{\# do not need to verify linear predictors, this will be done in the}
  \CommentTok{\# .testProbabilities() function}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{exp}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{base\_hazard\_at\_t }\SpecialCharTok{*} \FunctionTok{exp}\NormalTok{(lin\_predictors))}
  
  \CommentTok{\# Ensure valid predictions}
  \FunctionTok{.testProbabilities}\NormalTok{(surv\_probabilities)}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\CommentTok{\#\textquotesingle{} Note including lambda as an input here eliminates it from being passed to}
\CommentTok{\#\textquotesingle{}   the prediction method through the ellipsis}
\NormalTok{.predictSurvivalProb.survreg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, }
\NormalTok{                                         lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \DocumentationTok{\#\# Predict survival probabilities}
  
\NormalTok{  lin\_predictors }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(}\FunctionTok{predict}\NormalTok{(object, newdata, }\AttributeTok{type =} \StringTok{"lp"}\NormalTok{, ...),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain linear predictors."}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                               \})}
  \CommentTok{\# do not need to verify linear predictors, this will be done in the}
  \CommentTok{\# .testProbabilities() function}
                                   
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FloatTok{1.0} \SpecialCharTok{{-}}\NormalTok{ stats}\SpecialCharTok{::}\FunctionTok{pweibull}\NormalTok{(eval.time,}
                                              \AttributeTok{shape =} \FloatTok{1.0} \SpecialCharTok{/} \FunctionTok{exp}\NormalTok{(object}\SpecialCharTok{$}\NormalTok{scale),}
                                              \AttributeTok{scale =} \FunctionTok{exp}\NormalTok{(lin\_predictors))}
  \CommentTok{\# Ensure valid predictions}
  \FunctionTok{.testProbabilities}\NormalTok{(surv\_probabilities)}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{.predictSurvivalProb.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, }
\NormalTok{                                            eval.time, lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&}\NormalTok{ (}\FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata)),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&} 
      \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Convert to survreg object and use survreg method}
\NormalTok{  survreg\_object }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(SomaSurvival}\SpecialCharTok{::}\FunctionTok{convert2Survreg}\NormalTok{(object, lambda),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to convert \textasciigrave{}object\textasciigrave{} to \textasciigrave{}survreg\textasciigrave{}.}\SpecialCharTok{\textbackslash{}n\textbackslash{}t}\StringTok{"}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                             \})}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \FunctionTok{.predictSurvivalProb}\NormalTok{(survreg\_object, newdata, eval.time, ...)}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal function to test that probabilities are valid}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param predictions Numeric. The probabilities to test.}
\CommentTok{\#\textquotesingle{} @return Numeric. The probabilities with invalid values reset to NA\_real\_}
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.testProbabilities }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(predictions) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}predictions\textasciigrave{} must be numeric."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(predictions) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(predictions) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(predictions) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(predictions) }\SpecialCharTok{!=}\NormalTok{ 0L}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# convert non{-}finite (NA, NaN, Inf) values to NA\_real\_}
  \CommentTok{\# convert values outside of [0, 1] to NA\_real\_}
\NormalTok{  bad\_values }\OtherTok{\textless{}{-}} \SpecialCharTok{!}\FunctionTok{is.finite}\NormalTok{(predictions) }\SpecialCharTok{|}\NormalTok{ predictions }\SpecialCharTok{\textless{}} \FloatTok{0.0} \SpecialCharTok{|}\NormalTok{ predictions }\SpecialCharTok{\textgreater{}} \FloatTok{1.0}
  \ControlFlowTok{if}\NormalTok{ ( }\FunctionTok{any}\NormalTok{(bad\_values) ) \{}
\NormalTok{    predictions[bad\_values] }\OtherTok{\textless{}{-}} \ConstantTok{NA\_real\_}
    \FunctionTok{message}\NormalTok{(}\FunctionTok{value}\NormalTok{(}\FunctionTok{sum}\NormalTok{(bad\_value)), }\StringTok{" invalid probabilities have been set as NA."}\NormalTok{)}
\NormalTok{  \}}
  
\NormalTok{  predictions}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} Internal function to perform binning}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Provided a vector of values and a vector of bin boundaries, identify the }
\CommentTok{\#\textquotesingle{}   bin in which each value falls and the total number of values in each bin.}
\CommentTok{\#\textquotesingle{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param values A numeric or numeric vector. The values to bin and tally.}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The K+1 boundaries of K bins.}
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.boundaries\}\{A numeric vector. The provided probability bins.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bin.id\}\{An integer vector of the probability bin to which each case in }
\CommentTok{\#\textquotesingle{}   \textasciigrave{}newdata\textasciigrave{} is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A numeric vector of the total number of cases in each }
\CommentTok{\#\textquotesingle{}   probability bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.binData }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(values, bin.boundaries) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}values\textasciigrave{} must be a non{-}empty, numeric vector."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(values) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(values) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(values) }\SpecialCharTok{\&\&}
        \FunctionTok{length}\NormalTok{(values) }\SpecialCharTok{!=}\NormalTok{ 0L,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector of length \textgreater{} 1."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(bin.boundaries),}
    \StringTok{"All values in \textasciigrave{}bin.boundaries\textasciigrave{} must be unique."} \OtherTok{=} 
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{==} \FunctionTok{length}\NormalTok{(}\FunctionTok{unique}\NormalTok{(bin.boundaries)),}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} cannot contain NA or NaN values."} \OtherTok{=} 
      \FunctionTok{all}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \SpecialCharTok{!}\FunctionTok{is.nan}\NormalTok{(bin.boundaries)),}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be in increasing order."} \OtherTok{=} \SpecialCharTok{!}\FunctionTok{is.unsorted}\NormalTok{(bin.boundaries),}
    \StringTok{"\textasciigrave{}values\textasciigrave{} must be finite and in range of \textasciigrave{}bin.boundaries\textasciigrave{}."} \OtherTok{=} 
      \FunctionTok{all}\NormalTok{(}\FunctionTok{is.finite}\NormalTok{(values)) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(values }\SpecialCharTok{\textgreater{}=} \FunctionTok{min}\NormalTok{(bin.boundaries)) }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(values }\SpecialCharTok{\textless{}=} \FunctionTok{max}\NormalTok{(bin.boundaries))}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Identify bin membership based on the provided probabilities}
\NormalTok{  bins }\OtherTok{\textless{}{-}} \FunctionTok{findInterval}\NormalTok{(values, bin.boundaries, }\AttributeTok{all.inside =} \ConstantTok{TRUE}\NormalTok{)}
  
  \CommentTok{\# Tally the number of cases in each probability bin}
\NormalTok{  totals }\OtherTok{\textless{}{-}} \FunctionTok{tabulate}\NormalTok{(bins)}
  \FunctionTok{names}\NormalTok{(totals) }\OtherTok{\textless{}{-}}\NormalTok{ 1L}\SpecialCharTok{:}\NormalTok{(}\FunctionTok{length}\NormalTok{(bins)}\SpecialCharTok{{-}}\NormalTok{1L)}
  
  \CommentTok{\# Return a list of the results}
  \FunctionTok{list}\NormalTok{(}\StringTok{"bin.boundaries"} \OtherTok{=}\NormalTok{ bin.boundaries, }
       \StringTok{"bin.id"}         \OtherTok{=}\NormalTok{ bins, }
       \StringTok{"totals"}         \OtherTok{=}\NormalTok{ totals)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In this blended design, the estimation and testing of the survival probabilities is now available to the broader package; the input structure is not bloated for non-Elastic Net methods; and we can avoid duplication of code when the procedure for models are identical (as for \texttt{coxph} and \texttt{survreg}). Further, the tools can be extended to other non-model types, such as a numeric vector of predictions without modification of the tool's usage statement.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} S3 method for numeric vector objects}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.numeric }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}object\textasciigrave{} must be a non{-}empty numeric vector if predictions are provided."} \OtherTok{=}
      \FunctionTok{is.vector}\NormalTok{(object) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(object) }\SpecialCharTok{!=}\NormalTok{ 0L,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
        \FunctionTok{is.vector}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} 
        \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(object)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Bin and tally predicted probabilities}
  \FunctionTok{.binData}\NormalTok{(surv\_probabilities, bin.boundaries)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Some disadvantages of this design are that both the tool and the survival probability functions must be extended when new model types become available and the ``procedure'' can be obfuscated as it is implemented within each individual S3 extension of the tool. As future developers extend our tool, the procedure may subtly evolve away from our original intention. However, overall this blended approach presents the best of both worlds with fewer drawbacks.

\hypertarget{unit-testing}{%
\chapter{Unit Testing}\label{unit-testing}}

\hypertarget{general-comments-1}{%
\section{General Comments}\label{general-comments-1}}

\textbf{Test what your function \emph{does} not what it \emph{calls}.}

What we mean by this is, the goal of unit testing is to test the code that \textbf{you} wrote, not to test the code that other developers have written. We start from the premise that any third-party function that we make use of has already been rigorously tested. Take for example the \texttt{predict.survregnet()} method from \texttt{SomaSurvival} (modified slightly to facilitate this discussion).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{predict.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, lambda,}
                               \AttributeTok{type =} \FunctionTok{c}\NormalTok{(}\StringTok{"response"}\NormalTok{, }\StringTok{"lp"}\NormalTok{, }\StringTok{"linear"}\NormalTok{, }\StringTok{"quantile"}\NormalTok{,}
                                        \StringTok{"uquantile"}\NormalTok{, }\StringTok{"coefficients"}\NormalTok{),}
                               \AttributeTok{p =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{na.action =}\NormalTok{ stats}\SpecialCharTok{::}\NormalTok{na.pass, ...) \{}

  \DocumentationTok{\#\#\# Input Testing}
\NormalTok{  type }\OtherTok{\textless{}{-}} \FunctionTok{match.arg}\NormalTok{(type)}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=}
      \FunctionTok{missing}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata),}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a scalar numeric."} \OtherTok{=}
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&} 
      \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}p\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \FunctionTok{is.numeric}\NormalTok{(p) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(p) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(p) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ p }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}na.action\textasciigrave{} must be a function."} \OtherTok{=} \FunctionTok{is.function}\NormalTok{(na.action)}
\NormalTok{  )}

  \DocumentationTok{\#\#\# Input Processing}
\NormalTok{  survreg\_obj }\OtherTok{\textless{}{-}} \FunctionTok{convert2Survreg}\NormalTok{(object, lambda)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \ControlFlowTok{if}\NormalTok{ ( type }\SpecialCharTok{==} \StringTok{"coefficients"}\NormalTok{ ) \{}
    \FunctionTok{return}\NormalTok{(}\FunctionTok{data.frame}\NormalTok{(}\AttributeTok{pred =}\NormalTok{ survreg\_obj}\SpecialCharTok{$}\NormalTok{coefficients))}
\NormalTok{  \}}

  \ControlFlowTok{if}\NormalTok{ ( }\FunctionTok{missing}\NormalTok{(newdata) ) \{}
\NormalTok{    pred }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(survreg\_obj, }\AttributeTok{type =}\NormalTok{ type, }\AttributeTok{p =}\NormalTok{ p, }\AttributeTok{na.action =}\NormalTok{ na.action, ...)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    pred }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(survreg\_obj, }\AttributeTok{newdata =}\NormalTok{ newdata, }\AttributeTok{type =}\NormalTok{ type, }\AttributeTok{p =}\NormalTok{ p, }
                    \AttributeTok{na.action =}\NormalTok{ na.action, ...)}
\NormalTok{  \}}

  \DocumentationTok{\#\#\# Result construction and testing}
  \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{pred =}\NormalTok{ pred)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

After some testing and manipulation of the inputs provided by the user, this function simply calls the \texttt{predict.survreg()} function of the \texttt{survival} package. It is not our goal to test if the predictions returned by \texttt{predict.survreg()} are correct; as it is an external function, we assume that it is properly tested by the developers. Rather, we want to make sure that our testing and manipulation of the inputs are doing what we expect as well as verify that the structure of the \emph{call to} \texttt{predict.survreg()} is being properly formulated.

In the code below we have added comments specifying the tests that could be implemented for the unit test suite of this function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{predict.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, lambda,}
                               \AttributeTok{type =} \FunctionTok{c}\NormalTok{(}\StringTok{"response"}\NormalTok{, }\StringTok{"lp"}\NormalTok{, }\StringTok{"linear"}\NormalTok{, }\StringTok{"quantile"}\NormalTok{,}
                                        \StringTok{"uquantile"}\NormalTok{, }\StringTok{"coefficients"}\NormalTok{),}
                               \AttributeTok{p =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{na.action =}\NormalTok{ stats}\SpecialCharTok{::}\NormalTok{na.pass, ...) \{}

  \DocumentationTok{\#\#\# Input Testing}
  \DocumentationTok{\#\#\#\# {-} Ensure that an error is generated when \textasciigrave{}type\textasciigrave{} is an invalid value}
\NormalTok{  type }\OtherTok{\textless{}{-}} \FunctionTok{match.arg}\NormalTok{(type)}

  \DocumentationTok{\#\#\#\# {-} Ensure that an error is generated when \textasciigrave{}newdata\textasciigrave{} is provided but is not a }
  \DocumentationTok{\#\#\#\#   data.frame or soma\_adat}
  \DocumentationTok{\#\#\#\# {-} Ensure that an error is generated when \textasciigrave{}lambda\textasciigrave{} is not provided}
  \DocumentationTok{\#\#\#\# {-} Ensure that an error is generated when \textasciigrave{}lambda\textasciigrave{} is not numeric}
  \DocumentationTok{\#\#\#\# {-} Ensure that an error is generated when \textasciigrave{}lambda\textasciigrave{} is not a vector}
  \DocumentationTok{\#\#\#\# {-} Ensure that an error is generated when \textasciigrave{}lambda\textasciigrave{} is provided as a vector}
  \DocumentationTok{\#\#\#\#   of length \textgreater{} 1}
  \DocumentationTok{\#\#\#\# {-} Ensure that an error is generated when \textasciigrave{}lambda\textasciigrave{} is negative}
  \DocumentationTok{\#\#\#\# {-} Ensure that an error is generated when \textasciigrave{}p\textasciigrave{} is not numeric}
  \DocumentationTok{\#\#\#\# {-} Ensure that an error is generated when \textasciigrave{}p\textasciigrave{} is not a vector}
  \DocumentationTok{\#\#\#\# {-} Ensure that an error is generated when \textasciigrave{}p\textasciigrave{} is provided as a vector}
  \DocumentationTok{\#\#\#\#   of length \textgreater{} 1}
  \DocumentationTok{\#\#\#\# {-} Ensure that an error is generated when \textasciigrave{}p\textasciigrave{} is negative}
  \DocumentationTok{\#\#\#\# {-} Ensure that an error is generated when \textasciigrave{}na.action\textasciigrave{} is not a function}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=}
      \FunctionTok{missing}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata),}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a scalar numeric."} \OtherTok{=}
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&} 
      \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}p\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \FunctionTok{is.numeric}\NormalTok{(p) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(p) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(p) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ p }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}na.action\textasciigrave{} must be a function."} \OtherTok{=} \FunctionTok{is.function}\NormalTok{(na.action)}
\NormalTok{  )}

  \DocumentationTok{\#\#\# Input Processing}
  \DocumentationTok{\#\#\#\# Assume that convert2Survreg does what it is supposed to do.}
  \DocumentationTok{\#\#\#\# This line of code does need to be unit tested}
\NormalTok{  survreg\_obj }\OtherTok{\textless{}{-}} \FunctionTok{convert2Survreg}\NormalTok{(object, lambda)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \DocumentationTok{\#\#\#\# {-} Ensure that a data.frame of the coefficients for provided lambda value is}
  \DocumentationTok{\#\#\#\#   returned when \textasciigrave{}type = "coefficients"\textasciigrave{}}
  \ControlFlowTok{if}\NormalTok{ ( type }\SpecialCharTok{==} \StringTok{"coefficients"}\NormalTok{ ) \{}
    \FunctionTok{return}\NormalTok{(}\FunctionTok{data.frame}\NormalTok{(}\AttributeTok{pred =}\NormalTok{ survreg\_obj}\SpecialCharTok{$}\NormalTok{coefficients))}
\NormalTok{  \}}

  \ControlFlowTok{if}\NormalTok{ ( }\FunctionTok{missing}\NormalTok{(newdata) ) \{}
    \DocumentationTok{\#\#\#\# {-} Create a survreg object from the survregnet object using }
    \DocumentationTok{\#\#\#\#   convert2survreg(survregnet\_object, lambda = lambda); }
    \DocumentationTok{\#\#\#\#   assume a single lambda value}
    \DocumentationTok{\#\#\#\#   Test equality of all combinations (keeping in mind that this function}
    \DocumentationTok{\#\#\#\#    returns a data.frame and predict.survreg will return a vector)}
    \DocumentationTok{\#\#\#\#   {-} default inputs should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, type = "response")}
    \DocumentationTok{\#\#\#\#   {-} type = "lp" should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, type = "lp")}
    \DocumentationTok{\#\#\#\#   {-} type = "linear" should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, type = "linear")}
    \DocumentationTok{\#\#\#\#   {-} type = "quantile" (p taking default value) should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, type = "quantile", p = 0.5)}
    \DocumentationTok{\#\#\#\#   {-} type = "quantile"; p = 0.25 should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, type = "quantile", p = 0.25)}
    \DocumentationTok{\#\#\#\#   {-} type = "uquantile" (p taking default value) should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, type = "uquantile", p = 0.5)}
    \DocumentationTok{\#\#\#\#   {-} type = "uquantile"; p = 0.25 should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, type = "uquantile", p = 0.25)}
    \DocumentationTok{\#\#\#\#}
    \DocumentationTok{\#\#\#\# {-} pass an additional argument through the ellipsis}
    \DocumentationTok{\#\#\#\#   {-} default values with addition of se.fit = TRUE should be equal to}
    \DocumentationTok{\#\#\#\#   predict.survreg(survreg\_object, type = "response", se.fit = TRUE)}
\NormalTok{    pred }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(survreg\_obj, }\AttributeTok{type =}\NormalTok{ type, }\AttributeTok{p =}\NormalTok{ p, }\AttributeTok{na.action =}\NormalTok{ na.action, ...)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \DocumentationTok{\#\#\#\# {-} Create a survreg object from the survregnet object using }
    \DocumentationTok{\#\#\#\#   convert2survreg(survregnet\_object, lambda = lambda); }
    \DocumentationTok{\#\#\#\#   assume a single lambda value}
    \DocumentationTok{\#\#\#\#   Test equality of all combinations (keeping in mind that this function}
    \DocumentationTok{\#\#\#\#    returns a data.frame and predict.survreg will return a vector)}
    \DocumentationTok{\#\#\#\#   {-} default inputs should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, newdata, type = "response")}
    \DocumentationTok{\#\#\#\#   {-} type = "lp" should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, newdata, type = "lp")}
    \DocumentationTok{\#\#\#\#   {-} type = "linear" should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, newdata, type = "linear")}
    \DocumentationTok{\#\#\#\#   {-} type = "quantile" (p taking default value) should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, newdata, type = "quantile", p = 0.5)}
    \DocumentationTok{\#\#\#\#   {-} type = "quantile"; p = 0.25 should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, newdata, type = "quantile", p = 0.25)}
    \DocumentationTok{\#\#\#\#   {-} type = "uquantile" (p taking default value) should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, newdata, type = "uquantile", p = 0.5)}
    \DocumentationTok{\#\#\#\#   {-} type = "uquantile"; p = 0.25 should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, newdata, type = "uquantile", p = 0.25)}
    \DocumentationTok{\#\#\#\# }
    \DocumentationTok{\#\#\#\#   {-} set at least 1 case of \textasciigrave{}newdata\textasciigrave{} to NA}
    \DocumentationTok{\#\#\#\#     na.action = stats::na.omit should be equal to}
    \DocumentationTok{\#\#\#\#     predict.survreg(survreg\_object, newdata\_na, type = "response", }
    \DocumentationTok{\#\#\#\#                     na.action = stats::na.omit)}
    \DocumentationTok{\#\#\#\#}
    \DocumentationTok{\#\#\#\# {-} pass an additional argument through the ellipsis}
    \DocumentationTok{\#\#\#\#   {-} default values with addition of se.fit = TRUE should be equal to}
    \DocumentationTok{\#\#\#\#   predict.survreg(survreg\_object, type = "response", se.fit = TRUE)}
\NormalTok{    pred }\OtherTok{\textless{}{-}} \FunctionTok{predict}\NormalTok{(survreg\_obj, }\AttributeTok{newdata =}\NormalTok{ newdata, }\AttributeTok{type =}\NormalTok{ type, }\AttributeTok{p =}\NormalTok{ p, }
                    \AttributeTok{na.action =}\NormalTok{ na.action, ...)}
\NormalTok{  \}}

  \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{pred =}\NormalTok{ pred)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There are some additional tests that could be included. For example, ensuring that \texttt{na.action} is one of \texttt{na.omit}, \texttt{na.fail}, \texttt{na.omit}, or \texttt{na.fail} as well as ensuring that any inputs provided through the ellipsis are indeed formals of \texttt{predict.survreg()}. However, as these inputs are only \emph{passed} to \texttt{predict.survreg()} (we make no internal usage of these input) we can assume that \texttt{predict.survreg()} handles inappropriate values. Technically, we could omit any testing of \texttt{na.action} because we do not use it. However, because we explicitly include it as input and pass it to the \texttt{predict()} method, it is not a bad idea to at least ensure that it is the appropriate type of object, i.e., a function.

\hypertarget{unit-tests-for-chapter-2-example}{%
\section{Unit Tests for Chapter 2 Example}\label{unit-tests-for-chapter-2-example}}

To highlight some general recommendations for developing unit tests, we will make use of the implementations developed in Chapter 2. We will not cover every function.

\hypertarget{common-functions-1}{%
\subsection{Common Functions}\label{common-functions-1}}

Begin the test suite by developing tests for the common internal functions. This allows us to safely make use of these resources when testing functions that call the common functions, i.e., once \texttt{.bindata()} is fully tested, we can call \texttt{.bindata()} in any later test suite without needing to verify its returned value.

Because all of the implementations make use of the same utility functions \texttt{.binData()} and \texttt{testProbabilities()}, we develop these tests without concern for the overall design choice.

It is recommended that unit tests are developed for each component of the function: input testing, input processing, task implementation, and returned result. Typically, the final two components (task and result) will be combined.

We will begin with the \texttt{.binData()} function

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Internal function to perform binning}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Provided a vector of values and a vector of bin boundaries, }
\CommentTok{\#\textquotesingle{}   identify the bin in which each value falls and the total number of values}
\CommentTok{\#\textquotesingle{}   in each bin.}
\CommentTok{\#\textquotesingle{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @param values A numeric or numeric vector}
\CommentTok{\#\textquotesingle{} @param bin.boundaries Numeric vector. The k+1 boundaries of k bins.}
\CommentTok{\#\textquotesingle{} @return A list containing}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{bins\}\{A vector of the bin index to which each value is assigned.\}}
\CommentTok{\#\textquotesingle{} \textbackslash{}item\{totals\}\{A vector of the total number of cases in each bin.\}}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @keywords internal}
\NormalTok{.binData }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(values, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}values\textasciigrave{} must be a non{-}empty, numeric vector."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(values) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(values) }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(values) }\SpecialCharTok{\&\&}
      \FunctionTok{length}\NormalTok{(values) }\SpecialCharTok{!=}\NormalTok{ 0L,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector of length \textgreater{} 1."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} 
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{is.vector}\NormalTok{(bin.boundaries),}
    \StringTok{"All values in \textasciigrave{}bin.boundaries\textasciigrave{} must be unique."} \OtherTok{=} 
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{==} \FunctionTok{length}\NormalTok{(}\FunctionTok{unique}\NormalTok{(bin.boundaries)),}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} cannot contain NA or NaN values."} \OtherTok{=} 
      \FunctionTok{all}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \SpecialCharTok{!}\FunctionTok{is.nan}\NormalTok{(bin.boundaries)),}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be in increasing order."} \OtherTok{=} \SpecialCharTok{!}\FunctionTok{is.unsorted}\NormalTok{(bin.boundaries),}
    \StringTok{"\textasciigrave{}values\textasciigrave{} must be finite and in range of \textasciigrave{}bin.boundaries\textasciigrave{}."} \OtherTok{=} 
      \FunctionTok{all}\NormalTok{(}\FunctionTok{is.finite}\NormalTok{(values)) }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(values }\SpecialCharTok{\textgreater{}=} \FunctionTok{min}\NormalTok{(bin.boundaries)) }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(values }\SpecialCharTok{\textless{}=} \FunctionTok{max}\NormalTok{(bin.boundaries))}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Identify bin membership based on the provided probabilities}
\NormalTok{  bins }\OtherTok{\textless{}{-}} \FunctionTok{findInterval}\NormalTok{(values, bin.boundaries, }\AttributeTok{all.inside =} \ConstantTok{TRUE}\NormalTok{)}
  
  \CommentTok{\# Tally the number of cases in each probability bin}
\NormalTok{  totals }\OtherTok{\textless{}{-}} \FunctionTok{tabulate}\NormalTok{(bins)}
  \FunctionTok{names}\NormalTok{(totals) }\OtherTok{\textless{}{-}}\NormalTok{ 1L}\SpecialCharTok{:}\NormalTok{(}\FunctionTok{length}\NormalTok{(bins)}\SpecialCharTok{{-}}\NormalTok{1L)}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \FunctionTok{list}\NormalTok{(}\StringTok{"bin.boundaries"}  \OtherTok{=}\NormalTok{ bin.boundaries, }
       \StringTok{"bin.id"}          \OtherTok{=}\NormalTok{ bins, }
       \StringTok{"totals"}          \OtherTok{=}\NormalTok{ totals)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{unit-tests-for-input-testing}{%
\subsubsection{Unit tests for Input Testing}\label{unit-tests-for-input-testing}}

Ensure that all stopping conditions are triggered appropriately. This suite can be long, but it is, in the writers' opinion, the most important test suite. As they say -- GIGO or ``garbage in, garbage out.'' This series of tests will typically involve only the \texttt{testthat::expect\_error()} function.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{test\_that}\NormalTok{(}\StringTok{"Input Testing generates expected errors"}\NormalTok{, \{}
  \DocumentationTok{\#\# Use a fully named input structure to test for missing value failures.}
  \DocumentationTok{\#\#   This test ensures that if the function is called using a function}
  \DocumentationTok{\#\#   such as do.call, the elements of the list have been appropriate named.}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\AttributeTok{bin.boundaries =} \FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{)),}
               \StringTok{"\textasciigrave{}values\textasciigrave{} must be a numeric vector."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\AttributeTok{values =} \FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{)),}
               \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector of length \textgreater{} 1."}\NormalTok{)}
  
  \DocumentationTok{\#\# Next use an unnamed structure leaving 1 required input out.}
  \DocumentationTok{\#\# Here, because both \textasciigrave{}values\textasciigrave{} and \textasciigrave{}bin.boundaries\textasciigrave{} are vectors, the}
  \DocumentationTok{\#\# \textasciigrave{}bin.boundaries\textasciigrave{} missing error is triggered.}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{)),}
               \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector of length \textgreater{} 1."}\NormalTok{)}
  
  \DocumentationTok{\#\# Input{-}by{-}input, test the required characteristics}
  \DocumentationTok{\#\# specify fully valid inputs for all other input arguments}
  
  \DocumentationTok{\#\# \textasciigrave{}values\textasciigrave{} must be a numeric vector of length \textgreater{}= 1}
  \DocumentationTok{\#\# there is no need to test EVERY type of non{-}numeric object}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{)),}
               \StringTok{"\textasciigrave{}values\textasciigrave{} must be a numeric vector."}\NormalTok{)}
  \DocumentationTok{\#\# pass a matrix to ensure the "is.vector" fails; a numeric matrix will pass}
  \DocumentationTok{\#\# the is.numeric() test.}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{matrix}\NormalTok{(}\FloatTok{1.0}\NormalTok{, 2L, 2L), }\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{)),}
               \StringTok{"\textasciigrave{}values\textasciigrave{} must be a numeric vector of length \textgreater{} 1."}\NormalTok{)}
  \DocumentationTok{\#\# pass an empty numeric vector to ensure length() != 0 test fails}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{numeric}\NormalTok{(0L), }\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{)),}
               \StringTok{"\textasciigrave{}values\textasciigrave{} must be a numeric vector of length \textgreater{} 1."}\NormalTok{)}
  
  
  \DocumentationTok{\#\# \textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector of length \textgreater{} 1}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{), }\StringTok{"a"}\NormalTok{),}
               \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector of length \textgreater{} 1."}\NormalTok{)}
  \DocumentationTok{\#\# pass a matrix of length 1 to ensure that is.vector() test fails}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{), }\FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\NormalTok{, 1L, 1L)),}
               \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector of length \textgreater{} 1."}\NormalTok{)}
  \DocumentationTok{\#\# pass a scalar to ensure that the length() \textgreater{} 1 test fails}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{), }\FloatTok{1.0}\NormalTok{),}
               \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector of length \textgreater{} 1."}\NormalTok{)}

  \DocumentationTok{\#\# \textasciigrave{}bin.boundaries\textasciigrave{} must contain unique values}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{1.0}\NormalTok{, }\FloatTok{1.0}\NormalTok{)),}
               \StringTok{"All values in \textasciigrave{}bin.boundaries\textasciigrave{} must be unique."}\NormalTok{)}
  
  \DocumentationTok{\#\# \textasciigrave{}bin.boundaries\textasciigrave{} must be non{-}NA and non{-}NaN and unique}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{1.0}\NormalTok{, }\ConstantTok{NA}\NormalTok{)),}
               \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} cannot contain NA or NaN values."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{1.0}\NormalTok{, }\ConstantTok{NaN}\NormalTok{)),}
               \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} cannot contain NA or NaN values."}\NormalTok{)}
  
  \DocumentationTok{\#\# \textasciigrave{}bin.boundaries\textasciigrave{} must be in increasing order}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\FloatTok{0.1}\NormalTok{, }\FloatTok{0.4}\NormalTok{, }\FloatTok{0.3}\NormalTok{, }\FloatTok{1.0}\NormalTok{)),}
               \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be in increasing order."}\NormalTok{)}
  
  \DocumentationTok{\#\# \textasciigrave{}values\textasciigrave{} must be finite and within \textasciigrave{}bin.boundaries\textasciigrave{}}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{, }\DecValTok{2}\SpecialCharTok{:}\DecValTok{5}\NormalTok{),}
               \StringTok{"\textasciigrave{}values\textasciigrave{} must be finite and in range of \textasciigrave{}bin.boundaries\textasciigrave{}."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, }\ConstantTok{Inf}\NormalTok{), }\DecValTok{2}\SpecialCharTok{:}\DecValTok{5}\NormalTok{),}
               \StringTok{"\textasciigrave{}values\textasciigrave{} must be finite and in range of \textasciigrave{}bin.boundaries\textasciigrave{}."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, }\ConstantTok{NA}\NormalTok{), }\DecValTok{2}\SpecialCharTok{:}\DecValTok{5}\NormalTok{),}
               \StringTok{"\textasciigrave{}values\textasciigrave{} must be finite and in range of \textasciigrave{}bin.boundaries\textasciigrave{}."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, }\ConstantTok{NaN}\NormalTok{), }\DecValTok{2}\SpecialCharTok{:}\DecValTok{5}\NormalTok{),}
               \StringTok{"\textasciigrave{}values\textasciigrave{} must be finite and in range of \textasciigrave{}bin.boundaries\textasciigrave{}."}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{unit-tests-for-input-processing}{%
\subsubsection{Unit tests for Input Processing}\label{unit-tests-for-input-processing}}

This function does not have an input processing component.

\hypertarget{unit-tests-for-task-implementation-and-returned-result}{%
\subsubsection{Unit tests for Task Implementation and Returned Result}\label{unit-tests-for-task-implementation-and-returned-result}}

Here, it is often possible to implement the task in a different way. For example, using an explicit \texttt{for} loop rather than \texttt{apply} or using test data that can easily be manipulated or evaluated. We will show a couple of options here -- exactly which tests best suit the situation depends heavily on the complexity of the task. The goal is to ensure that \textbf{ALL} new code works as expected assuming that the inputs have passed the input testing phase.

If you are not able to test every line directly, this may be an indication that an intermediate step should be broken off into its own fully testable function.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{test\_that}\NormalTok{(}\StringTok{"Task Implementation generates expected result"}\NormalTok{, \{}
  \DocumentationTok{\#\# First, verify that the output returned by the function has the basic}
  \DocumentationTok{\#\# characteristics that we expect: a list with 3 elements with appropriate names}
\NormalTok{  test\_object }\OtherTok{\textless{}{-}} \FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FloatTok{1.0}\NormalTok{, }\FloatTok{2.0}\NormalTok{, }\FloatTok{3.0}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\FloatTok{1.0}\NormalTok{, }\FloatTok{2.0}\NormalTok{, }\FloatTok{3.0}\NormalTok{))}
  \FunctionTok{expect\_true}\NormalTok{(}\FunctionTok{is.list}\NormalTok{(test\_object))}
  \FunctionTok{expect\_length}\NormalTok{(test\_object, 3L)}
  \FunctionTok{expect\_named}\NormalTok{(test\_object, }\FunctionTok{c}\NormalTok{(}\StringTok{"bin.boundaries"}\NormalTok{, }\StringTok{"bin.id"}\NormalTok{, }\StringTok{"totals"}\NormalTok{))}
  
  \DocumentationTok{\#\# Here, we opt to use an alternative implementation.}
  \DocumentationTok{\#\#   We don\textquotesingle{}t need to include input tests, etc., and it doesn\textquotesingle{}t need}
  \DocumentationTok{\#\#   to be efficient {-}{-} just COMPLETELY DIFFERENT and CORRECT. }
  \DocumentationTok{\#\#   It is recommended that this version of the implementation be "simple" }
  \DocumentationTok{\#\#   and, when possible, avoids using convenience functions}
  \FunctionTok{.local\_task}\NormalTok{(values, bin.boundaries) \{}
    
\NormalTok{    bins   }\OtherTok{\textless{}{-}} \FunctionTok{integer}\NormalTok{(}\FunctionTok{length}\NormalTok{(values))}
\NormalTok{    totals }\OtherTok{\textless{}{-}} \FunctionTok{integer}\NormalTok{(}\FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{{-}}\NormalTok{ 1L)}
    
    \ControlFlowTok{for}\NormalTok{ ( i }\ControlFlowTok{in} \FunctionTok{seq\_along}\NormalTok{(values) ) \{}
      \CommentTok{\# findInterval() returns k that satisfies bin[k] \textless{}= x \textless{} bin[k+1]}
\NormalTok{      bins[i] }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(values[i] }\SpecialCharTok{\textgreater{}=}\NormalTok{ bin.boundaries)}
      
      \CommentTok{\# we set \textasciigrave{}all.inside = TRUE\textasciigrave{} {-}{-} need to implement this clamping}
      \CommentTok{\# any value \textgreater{}= max(bin.boundaries) is shifted to the last bin}
      \CommentTok{\# Note that we do not need to consider the condition value \textless{} min(bin.boundaries)}
      \CommentTok{\# because our input testing stops if any value is outside of the range}
      \CommentTok{\# of bin.boundaries}
\NormalTok{      bins[i] }\OtherTok{\textless{}{-}} \FunctionTok{min}\NormalTok{(bins[i], }\FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{{-}}\NormalTok{ 1L)}
\NormalTok{      totals[bins[i]] }\OtherTok{\textless{}{-}}\NormalTok{ totals[bins[i]] }\SpecialCharTok{+}\NormalTok{ 1L}
\NormalTok{    \}}
    \FunctionTok{list}\NormalTok{(}\StringTok{"bin.boundaries"} \OtherTok{=}\NormalTok{ bin.boundaries, }
         \StringTok{"bin.id"}         \OtherTok{=}\NormalTok{ bins, }
         \StringTok{"totals"}         \OtherTok{=}\NormalTok{ totals)}
\NormalTok{  \}}
  
  \DocumentationTok{\#\#\# Test a variety of inputs ranges, lengths, types}
  
  \DocumentationTok{\#\# "integer{-}like" numeric with values at the extrema of \textasciigrave{}bin.boundaries\textasciigrave{}}
  \FunctionTok{expect\_equal}\NormalTok{(}\FunctionTok{.local\_task}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{), }\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{),}
               \FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{), }\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{))}
  \DocumentationTok{\#\# numeric vector}
  \FunctionTok{expect\_equal}\NormalTok{(}\FunctionTok{.local\_task}\NormalTok{(withr}\SpecialCharTok{::}\FunctionTok{with\_seed}\NormalTok{(42L, stats}\SpecialCharTok{::}\FunctionTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{)), }
                           \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{)),}
               \FunctionTok{.binData}\NormalTok{(withr}\SpecialCharTok{::}\FunctionTok{with\_seed}\NormalTok{(42L, stats}\SpecialCharTok{::}\FunctionTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{)), }
                        \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{)))}
  
  \DocumentationTok{\#\#\# Test extremes}
  
  \DocumentationTok{\#\# A single \textasciigrave{}value\textasciigrave{}}
  \FunctionTok{expect\_equal}\NormalTok{(}\FunctionTok{.local\_task}\NormalTok{(}\FloatTok{10.0}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{5.0}\NormalTok{, }\FloatTok{20.0}\NormalTok{)),}
               \FunctionTok{.binData}\NormalTok{(}\FloatTok{10.0}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{5.0}\NormalTok{, }\FloatTok{20.0}\NormalTok{)))}
  
  \DocumentationTok{\#\# minimum vector length for \textasciigrave{}bin.boundaries\textasciigrave{} definition}
  \FunctionTok{expect\_equal}\NormalTok{(}\FunctionTok{.local\_task}\NormalTok{(}\FloatTok{10.0}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{20.0}\NormalTok{)),}
               \FunctionTok{.binData}\NormalTok{(}\FloatTok{10.0}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{20.0}\NormalTok{)))}
  
  \DocumentationTok{\#\# Infinities in boundaries are properly handled}
  \FunctionTok{expect\_equal}\NormalTok{(}\FunctionTok{.local\_task}\NormalTok{(}\FloatTok{10.0}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\ConstantTok{Inf}\NormalTok{, }\ConstantTok{Inf}\NormalTok{)),}
               \FunctionTok{.binData}\NormalTok{(}\FloatTok{10.0}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\ConstantTok{Inf}\NormalTok{, }\ConstantTok{Inf}\NormalTok{)))}
  
  \DocumentationTok{\#\# Next, we assume simple inputs for which we can easily construct}
  \DocumentationTok{\#\#  the expected output, without requiring a call to an (UNTESTED)}
  \DocumentationTok{\#\#  internal function {-}{-} sometimes these types of tests are more robust.}
  \DocumentationTok{\#\#  For example, it is possible that our second implementation will }
  \DocumentationTok{\#\#  include assumptions that we didn\textquotesingle{}t realize we made.}
  \FunctionTok{expect\_equal}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{), }\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{),}
               \FunctionTok{list}\NormalTok{(}\StringTok{"bin.boundaries"} \OtherTok{=} \DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{,}
                    \StringTok{"bin.id"}         \OtherTok{=} \FunctionTok{c}\NormalTok{(1L, 2L, 2L, 1L, 2L, 2L),}
                    \StringTok{"total"}          \OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"1"} \OtherTok{=}\NormalTok{ 2L, }\StringTok{"2"} \OtherTok{=}\NormalTok{ 4L))}
               
  \FunctionTok{expect\_equal}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.2}\NormalTok{, }\FloatTok{0.3}\NormalTok{, }\FloatTok{0.4}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{0.6}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\FloatTok{0.8}\NormalTok{, }\FloatTok{0.9}\NormalTok{, }\FloatTok{1.0}\NormalTok{), }
                        \FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.25}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{0.75}\NormalTok{, }\FloatTok{1.0}\NormalTok{)),}
               \FunctionTok{list}\NormalTok{(}\StringTok{"bin.boundaries"} \OtherTok{=} \FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.25}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{0.75}\NormalTok{, }\FloatTok{1.0}\NormalTok{),}
                    \StringTok{"bin.id"}         \OtherTok{=} \FunctionTok{c}\NormalTok{(1L, 1L, 1L, 2L, 2L, 3L, 3L, 4L, 4L, 4L),}
                    \StringTok{"total"}          \OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"1"} \OtherTok{=}\NormalTok{ 3L, }\StringTok{"2"} \OtherTok{=}\NormalTok{ 2L, }\StringTok{"3"} \OtherTok{=}\NormalTok{ 2L, }\StringTok{"4"} \OtherTok{=}\NormalTok{ 3L))}
               
  \FunctionTok{expect\_equal}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.2}\NormalTok{, }\FloatTok{0.3}\NormalTok{, }\FloatTok{0.4}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{0.6}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\FloatTok{0.8}\NormalTok{, }\FloatTok{0.9}\NormalTok{, }\FloatTok{1.0}\NormalTok{), }
                        \FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{1.0}\NormalTok{)),}
               \FunctionTok{list}\NormalTok{(}\StringTok{"bin.boundaries"} \OtherTok{=} \FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.25}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{0.75}\NormalTok{, }\FloatTok{1.0}\NormalTok{),}
                    \StringTok{"bin.id"}         \OtherTok{=} \FunctionTok{c}\NormalTok{(1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L),}
                    \StringTok{"total"}          \OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"1"} \OtherTok{=}\NormalTok{ 10L))}
               
  \FunctionTok{expect\_equal}\NormalTok{(}\FunctionTok{.binData}\NormalTok{(}\FloatTok{5.0}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{10.0}\NormalTok{)),}
               \FunctionTok{list}\NormalTok{(}\StringTok{"bin.boundaries"} \OtherTok{=} \FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{10.0}\NormalTok{),}
                    \StringTok{"bin.id"}         \OtherTok{=}\NormalTok{ 1L,}
                    \StringTok{"total"}          \OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"1"} \OtherTok{=}\NormalTok{ 1L))}
\ErrorTok{\}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Similar tests can be constructed for \texttt{.testProbabilities()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{test\_that}\NormalTok{(}\StringTok{"\textasciigrave{}.testProbabilities()\textasciigrave{} returns expected errors."}\NormalTok{, \{}
  \DocumentationTok{\#\# Input Testing}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.testProbabilities}\NormalTok{(), }\StringTok{"\textasciigrave{}predictions\textasciigrave{} must be numeric."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.testProbabilities}\NormalTok{(}\StringTok{"a"}\NormalTok{), }\StringTok{"\textasciigrave{}predictions\textasciigrave{} must be numeric."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.testProbabilities}\NormalTok{(}\FunctionTok{matrix}\NormalTok{(}\FloatTok{1.0}\NormalTok{, 2L, 2L)), }
               \StringTok{"\textasciigrave{}predictions\textasciigrave{} must be numeric."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{.testProbabilities}\NormalTok{(}\FunctionTok{numeric}\NormalTok{(}\DecValTok{0}\NormalTok{)), }
               \StringTok{"\textasciigrave{}predictions\textasciigrave{} must be numeric."}\NormalTok{)}
\NormalTok{\})}

\FunctionTok{test\_that}\NormalTok{(}\StringTok{"\textasciigrave{}.testProbabilities()\textasciigrave{} returns expected messages and results."}\NormalTok{, \{}
  \DocumentationTok{\#\# Task Implementation and Result}
  \CommentTok{\# ensure non{-}finite values are reset to NA and that}
  \CommentTok{\# the correct message is generated}
  \FunctionTok{expect\_message}\NormalTok{(out }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\ConstantTok{Inf}\NormalTok{, }\ConstantTok{Inf}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\ConstantTok{NaN}\NormalTok{)),}
                 \StringTok{"4 invalid probabilities have been set to NA."}\NormalTok{)}
  \FunctionTok{expect\_equal}\NormalTok{(out, }\FunctionTok{rep}\NormalTok{(}\ConstantTok{NA\_real\_}\NormalTok{, 4L))}
  
  \CommentTok{\# ensure that finite values out of range are reset to NA and that}
  \CommentTok{\# the correct message is generated}
  \FunctionTok{expect\_message}\NormalTok{(out }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{0.1}\NormalTok{, }\FloatTok{0.0}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{, }\FloatTok{1.1}\NormalTok{)),}
                 \StringTok{"2 invalid probabilities have been set to NA."}\NormalTok{)}
  \FunctionTok{expect\_equal}\NormalTok{(out, }\FunctionTok{c}\NormalTok{(}\ConstantTok{NA\_real\_}\NormalTok{, }\FloatTok{0.0}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{, }\ConstantTok{NA\_real\_}\NormalTok{))}
  
  \CommentTok{\# ensure that a vector of all valid values does not generate a message}
  \CommentTok{\# and returned object is the same as the input object}
  \FunctionTok{expect\_message}\NormalTok{(out }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FloatTok{0.1}\NormalTok{, }\FloatTok{0.2}\NormalTok{, }\FloatTok{0.99}\NormalTok{)), }\ConstantTok{NA}\NormalTok{)}
  \FunctionTok{expect\_equal}\NormalTok{(out, }\FunctionTok{c}\NormalTok{(}\FloatTok{0.1}\NormalTok{, }\FloatTok{0.2}\NormalTok{, }\FloatTok{0.99}\NormalTok{))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{s3-based-design}{%
\section{S3 Based Design}\label{s3-based-design}}

We shift our attention now to the inidividual S3 methods of this design, one generic, one default, and three extensions defined for object of class \texttt{coxph}, \texttt{survreg}, and \texttt{survregnet}.

There is no need to test the generic method. And, the default method is trivially tested.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{test\_that}\NormalTok{(}\StringTok{"\textasciigrave{}survProbBins.default()\textasciigrave{} is correctly triggered"}\NormalTok{, \{}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(}\FloatTok{1.0}\NormalTok{),}
               \StringTok{"\textasciigrave{}survProbBins()\textasciigrave{} does not yet support objects of class \textquotesingle{}numeric\textquotesingle{}."}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{s3-extensions-1}{%
\subsection{S3 Extensions}\label{s3-extensions-1}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}survival::coxph()\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.coxph }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&} \FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&}
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \DocumentationTok{\#\# Predict survival probabilities}
  
  \CommentTok{\# retrieve baseline hazard}
\NormalTok{  base\_hazard }\OtherTok{\textless{}{-}}\NormalTok{ survival}\SpecialCharTok{::}\FunctionTok{basehaz}\NormalTok{(object)}
  \CommentTok{\# identify time{-}point in baseline hazard nearest the specified evaluation time}
\NormalTok{  t\_idx       }\OtherTok{\textless{}{-}} \FunctionTok{which.min}\NormalTok{(}\FunctionTok{abs}\NormalTok{(eval.time }\SpecialCharTok{{-}}\NormalTok{ base\_hazard[, 2L]))}
  
\NormalTok{  base\_hazard\_at\_t }\OtherTok{\textless{}{-}}\NormalTok{ base\_hazard[t\_idx, 1L]}
  
  \CommentTok{\# ensure that baseline hazard is a valid value (not NA, NaN, Inf)}
  \ControlFlowTok{if}\NormalTok{ ( }\SpecialCharTok{!}\FunctionTok{is.finite}\NormalTok{(base\_hazard\_at\_t) ) \{}
    \FunctionTok{stop}\NormalTok{(}\StringTok{"Invalid baseline hazard "}\NormalTok{, }\FunctionTok{value}\NormalTok{(base\_hazard\_at\_t), }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{  \}}
  \FunctionTok{message}\NormalTok{(}\StringTok{"Survival probability evaluated at t = "}\NormalTok{, }\FunctionTok{value}\NormalTok{(base\_hazard[t\_idx, 2L]))}

  \CommentTok{\# get linear predictors for newdata}
\NormalTok{  lin\_predictors }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(}\FunctionTok{predict}\NormalTok{(object, newdata, }\AttributeTok{type =} \StringTok{"lp"}\NormalTok{, ...),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain linear predictors."}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                               \})}
  \CommentTok{\# do not need to verify linear predictors, this will be done in the}
  \CommentTok{\# .testProbabilities() function}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{exp}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{base\_hazard\_at\_t }\SpecialCharTok{*} \FunctionTok{exp}\NormalTok{(lin\_predictors))}
  
  \CommentTok{\# Ensure valid predictions}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(surv\_probabilities)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  
  \CommentTok{\# Bin and tally predicted probabilities}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.binData}\NormalTok{(surv\_probabilities, bin.boundaries)}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# No further manipulation of the result of .binData() is required}
\NormalTok{  result}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}survival::survreg\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survreg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&} \FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be numeric."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&}
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{)}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \DocumentationTok{\#\# Predict survival probabilities}
  
\NormalTok{  lin\_predictors }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(}\FunctionTok{predict}\NormalTok{(object, newdata, }\AttributeTok{type =} \StringTok{"lp"}\NormalTok{, ...),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to obtain linear predictors."}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                               \})}
  \CommentTok{\# do not need to verify linear predictors, this will be done in the}
  \CommentTok{\# .testProbabilities() function}
                                   
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FloatTok{1.0} \SpecialCharTok{{-}}\NormalTok{ stats}\SpecialCharTok{::}\FunctionTok{pweibull}\NormalTok{(eval.time,}
                                              \AttributeTok{shape =} \FloatTok{1.0} \SpecialCharTok{/} \FunctionTok{exp}\NormalTok{(object}\SpecialCharTok{$}\NormalTok{scale),}
                                              \AttributeTok{scale =} \FunctionTok{exp}\NormalTok{(lin\_predictors))}
  \CommentTok{\# Ensure valid predictions}
\NormalTok{  surv\_probabilities }\OtherTok{\textless{}{-}} \FunctionTok{.testProbabilities}\NormalTok{(surv\_probabilities)}
  
  \DocumentationTok{\#\#\# Task Implementation}
  \CommentTok{\# Bin and tally predicted probabilities}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{.binData}\NormalTok{(surv\_probabilities, bin.boundaries)}
  
  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# No further manipulation of the result of .binData() is required}
\NormalTok{  result}
\NormalTok{\}}

\CommentTok{\#\textquotesingle{} S3 method for objects returned by \textasciigrave{}SomaSurvival::fitSurvregnet\textasciigrave{}}
\CommentTok{\#\textquotesingle{} @noRd}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{survProbBins.survregnet }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(object, newdata, eval.time, bin.boundaries,}
\NormalTok{                                    lambda, ...) \{}
  \DocumentationTok{\#\#\# Input Testing}
  \CommentTok{\# We forego testing for appropriate covariates in \textasciigrave{}newdata\textasciigrave{}, which will}
  \CommentTok{\#   be inherent in the procedure used to obtain predictions}
  \FunctionTok{stopifnot}\NormalTok{(}
    \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."} \OtherTok{=} 
      \SpecialCharTok{!}\NormalTok{missing }\SpecialCharTok{\&\&} \FunctionTok{is.data.frame}\NormalTok{(newdata) }\SpecialCharTok{||} \FunctionTok{is.soma\_adat}\NormalTok{(newdata),}
    \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be numeric."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(eval.time) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(eval.time) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ eval.time }\SpecialCharTok{\textgreater{}} \FloatTok{0.0}\NormalTok{,}
    \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(bin.boundaries) }\SpecialCharTok{\&\&}
      \FunctionTok{length}\NormalTok{(bin.boundaries) }\SpecialCharTok{\textgreater{}}\NormalTok{ 1L }\SpecialCharTok{\&\&} \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}\NormalTok{) }\SpecialCharTok{\&\&} 
      \FunctionTok{all}\NormalTok{(bin.boundaries }\SpecialCharTok{\textless{}=} \FloatTok{1.0}\NormalTok{),}
    \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."} \OtherTok{=} 
      \SpecialCharTok{!}\FunctionTok{missing}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{is.numeric}\NormalTok{(lambda) }\SpecialCharTok{\&\&} 
      \FunctionTok{is.vector}\NormalTok{(lambda) }\SpecialCharTok{\&\&} \FunctionTok{length}\NormalTok{(lambda) }\SpecialCharTok{==}\NormalTok{ 1L }\SpecialCharTok{\&\&}\NormalTok{ lambda }\SpecialCharTok{\textgreater{}=} \FloatTok{0.0}
\NormalTok{  )}
  
  \DocumentationTok{\#\#\# Input Processing}
  \CommentTok{\# Convert to survreg object and use survreg method}
\NormalTok{  survreg\_object }\OtherTok{\textless{}{-}} \FunctionTok{tryCatch}\NormalTok{(SomaSurvival}\SpecialCharTok{::}\FunctionTok{convert2Survreg}\NormalTok{(object, lambda),}
                             \AttributeTok{error =} \ControlFlowTok{function}\NormalTok{(e) \{}
                               \FunctionTok{stop}\NormalTok{(}\StringTok{"Unable to convert \textasciigrave{}object\textasciigrave{} to \textasciigrave{}survreg\textasciigrave{}.}\SpecialCharTok{\textbackslash{}n\textbackslash{}t}\StringTok{"}\NormalTok{,}
\NormalTok{                                    e}\SpecialCharTok{$}\NormalTok{message, }\AttributeTok{call. =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{                             \})}
  
  \DocumentationTok{\#\#\# Task Implementation}
\NormalTok{  result }\OtherTok{\textless{}{-}} \FunctionTok{survProbBins}\NormalTok{(survreg\_object, newdata, eval.time, bin.boundaries, ...)}

  \DocumentationTok{\#\#\# Result Construction and Testing}
  \CommentTok{\# No further manipulation of the result of .binData() is required}
\NormalTok{  result}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{input-testing-3}{%
\subsubsection{Input Testing}\label{input-testing-3}}

Notice that with the exception of the \texttt{lambda} input required for \texttt{survProbBins.survregnet()}, the input testing elements are identical. One could develop the unit tests for each S3 extension separately, or streamline the procedure by defining a single internal expectation that each model type uses. Specifically, we can define the following expectation in the Setup section of the test file

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{expect\_input\_fails }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(model, data) \{}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(model), }
               \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(model, }\FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{5}\NormalTok{)),}
               \StringTok{"\textasciigrave{}newdata\textasciigrave{} must be a data.frame or soma\_adat."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(model, data),}
               \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(model, data, }\FunctionTok{matrix}\NormalTok{(}\FloatTok{1.0}\NormalTok{, 1L, 1L)),}
               \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(model, data, }\FunctionTok{c}\NormalTok{(}\FloatTok{1.0}\NormalTok{, }\FloatTok{1.0}\NormalTok{)),}
               \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(model, data, }\SpecialCharTok{{-}}\FloatTok{1.5}\NormalTok{),}
               \StringTok{"\textasciigrave{}eval.time\textasciigrave{} must be a positive scalar."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(model, data, }\FloatTok{1.0}\NormalTok{),}
               \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(model, data, }\FloatTok{1.0}\NormalTok{, }\StringTok{"a"}\NormalTok{),}
               \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(model, data, }\FloatTok{1.0}\NormalTok{, }\FloatTok{1.0}\NormalTok{),}
               \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(model, data, }\FloatTok{1.0}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{1.0}\NormalTok{, }\FloatTok{0.0}\NormalTok{, }\FloatTok{1.0}\NormalTok{)),}
               \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."}\NormalTok{)}
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(model, data, }\FloatTok{1.0}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\FloatTok{0.0}\NormalTok{, }\FloatTok{1.0}\NormalTok{, }\FloatTok{2.0}\NormalTok{)),}
               \StringTok{"\textasciigrave{}bin.boundaries\textasciigrave{} must be a numeric vector in [0, 1]."}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

And employ this function to test that the input testing is behaving as expected.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{test\_that}\NormalTok{(}\StringTok{"\textasciigrave{}survProbBins.coxph()\textasciigrave{} input tests return expected errors"}\NormalTok{, \{}
\NormalTok{  apts }\OtherTok{\textless{}{-}}\NormalTok{ SomaReadr}\SpecialCharTok{::}\FunctionTok{getAnalytes}\NormalTok{(SomaSurvival}\SpecialCharTok{::}\NormalTok{sim\_surv\_data)}
\NormalTok{  form }\OtherTok{\textless{}{-}}\NormalTok{ SomaSurvival}\SpecialCharTok{::}\FunctionTok{createSurvFormula}\NormalTok{(}\AttributeTok{features =}\NormalTok{ apts, }
                                          \AttributeTok{time     =} \StringTok{"time\_lower"}\NormalTok{,}
                                          \AttributeTok{status   =} \StringTok{"status\_right"}\NormalTok{)}
\NormalTok{  cox\_model }\OtherTok{\textless{}{-}}\NormalTok{ survival}\SpecialCharTok{::}\FunctionTok{coxph}\NormalTok{(form, SomaSurvival}\SpecialCharTok{::}\NormalTok{sim\_surv\_data)}
  \FunctionTok{expect\_input\_fails}\NormalTok{(cox\_model, SomaSurvival}\SpecialCharTok{::}\NormalTok{sim\_surv\_data)}
\NormalTok{\})}

\FunctionTok{test\_that}\NormalTok{(}\StringTok{"\textasciigrave{}survProbBins.survreg()\textasciigrave{} input tests return expected errors"}\NormalTok{, \{}
\NormalTok{  apts }\OtherTok{\textless{}{-}}\NormalTok{ SomaReadr}\SpecialCharTok{::}\FunctionTok{getAnalytes}\NormalTok{(SomaSurvival}\SpecialCharTok{::}\NormalTok{sim\_surv\_data)}
\NormalTok{  form }\OtherTok{\textless{}{-}}\NormalTok{ SomaSurvival}\SpecialCharTok{::}\FunctionTok{createSurvFormula}\NormalTok{(}\AttributeTok{features =}\NormalTok{ apts, }
                                          \AttributeTok{time =} \StringTok{"time\_lower"}\NormalTok{,}
                                          \AttributeTok{status =} \StringTok{"status\_right"}\NormalTok{)}
\NormalTok{  survreg\_model }\OtherTok{\textless{}{-}}\NormalTok{ survival}\SpecialCharTok{::}\FunctionTok{survreg}\NormalTok{(form, SomaSurvival}\SpecialCharTok{::}\NormalTok{sim\_surv\_data)}
  \FunctionTok{expect\_input\_fails}\NormalTok{(survreg\_model, SomaSurvival}\SpecialCharTok{::}\NormalTok{sim\_surv\_data)}
\NormalTok{\})}

\FunctionTok{test\_that}\NormalTok{(}\StringTok{"\textasciigrave{}survProbBins.survregnet()\textasciigrave{} input tests return expected errors"}\NormalTok{, \{}
\NormalTok{  apts }\OtherTok{\textless{}{-}}\NormalTok{ SomaReadr}\SpecialCharTok{::}\FunctionTok{getAnalytes}\NormalTok{(SomaSurvival}\SpecialCharTok{::}\NormalTok{sim\_surv\_data)}
\NormalTok{  form }\OtherTok{\textless{}{-}}\NormalTok{ SomaSurvival}\SpecialCharTok{::}\FunctionTok{createSurvFormula}\NormalTok{(}\AttributeTok{features =}\NormalTok{ apts, }
                                          \AttributeTok{time     =} \StringTok{"time\_lower"}\NormalTok{,}
                                          \AttributeTok{status   =} \StringTok{"status\_right"}\NormalTok{)}
\NormalTok{  grid }\OtherTok{\textless{}{-}}\NormalTok{ SomaSurvival}\SpecialCharTok{::}\FunctionTok{calcEnetGrid}\NormalTok{(form, SomaSurvival}\SpecialCharTok{::}\NormalTok{sim\_surv\_data,}
                                     \AttributeTok{.alpha =} \FloatTok{0.2}\NormalTok{, }\AttributeTok{n.lambda =} \DecValTok{5}\NormalTok{)}
\NormalTok{  survregnet\_model }\OtherTok{\textless{}{-}}\NormalTok{ SomaSurvival}\SpecialCharTok{::}\FunctionTok{fitSurvregnet}\NormalTok{(form, SomaSurvival}\SpecialCharTok{::}\NormalTok{sim\_surv\_data,}
                                                  \AttributeTok{tune.grid =}\NormalTok{ grid, }\AttributeTok{alpha =} \FloatTok{0.2}\NormalTok{)}
  \FunctionTok{expect\_input\_fails}\NormalTok{(survregnet\_model, SomaSurvival}\SpecialCharTok{::}\NormalTok{sim\_surv\_data)}
  
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(survregnet\_model, SomaSurvival}\SpecialCharTok{::}\NormalTok{sim\_surv\_data,}
                            \AttributeTok{eval.time =} \FloatTok{10.0}\NormalTok{, }\AttributeTok{bin.boundaries =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{)),}
               \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."}\NormalTok{)}
  
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(survregnet\_model, SomaSurvival}\SpecialCharTok{::}\NormalTok{sim\_surv\_data,}
                            \AttributeTok{eval.time =} \FloatTok{10.0}\NormalTok{, }\AttributeTok{bin.boundaries =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{),}
                            \AttributeTok{lambda =} \StringTok{"a"}\NormalTok{),}
               \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."}\NormalTok{)}
  
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(survregnet\_model, SomaSurvival}\SpecialCharTok{::}\NormalTok{sim\_surv\_data,}
                            \AttributeTok{eval.time =} \FloatTok{10.0}\NormalTok{, }\AttributeTok{bin.boundaries =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{),}
                            \AttributeTok{lambda =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)),}
               \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."}\NormalTok{)}
  
  \FunctionTok{expect\_error}\NormalTok{(}\FunctionTok{survProbBins}\NormalTok{(survregnet\_model, SomaSurvival}\SpecialCharTok{::}\NormalTok{sim\_surv\_data,}
                            \AttributeTok{eval.time =} \FloatTok{10.0}\NormalTok{, }\AttributeTok{bin.boundaries =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{1.0}\NormalTok{),}
                            \AttributeTok{lambda =} \SpecialCharTok{{-}}\FloatTok{0.5}\NormalTok{),}
               \StringTok{"\textasciigrave{}lambda\textasciigrave{} must be a non{-}negative scalar."}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{input-processing-3}{%
\subsubsection{Input Processing}\label{input-processing-3}}

This is our first indication that the S3 based design may not be the most robust choice w.r.t. unit testing. Specifically, there is no clear way to test the input processing steps. We can only implement these steps locally and validate that \texttt{survProbBins()} returns the expected results assuming that the input processing steps are accurate.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{test\_that}\NormalTok{(}\StringTok{"\textasciigrave{}.survProbBins.coxph()\textasciigrave{} returns expected results"}\NormalTok{, \{}
  
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

STILL NEEDS TO BE WRITTEN

Mention inability to test survival vs event probabilities

Bring in framework S3 methods to show how to test this

POINTS YET TO MAKE

Avoid hard-coding values when possible-- they can be much harder to maintain.

Just like function development, avoid repeated code. If the test structures are the same for several test groups, create a local function defining the test structure and pass the values to be tested (give example)

Can recreate the behavior of the testthat expect\_* functions (give example)

Hoping that we will implement 2 flags. First flag is nightly checks of the full test suite -- testing all internal functions, etc. Second flag is a PR check level, skips the potentially longer duration units tests of each component, but ensures that the final result is what we expect.

\hypertarget{pull-request-pr-peer-review}{%
\chapter{Pull Request (PR) Peer Review}\label{pull-request-pr-peer-review}}

Let's face it -- we are not perfect. When we are in the thick of bug hunting or developing a new tool from scratch, it is easy to get tunnel vision or code blind. The PR peer review is meant to be a collaborative process that provides an opportunity to put a fresh set of eyes on the project. All of us have very different backgrounds and areas of expertise, and we approach problems from different perspectives. We can take advantage of this diversity to make the first level review process both an opportunity to ensure our tools are general, robust, and user-friendly as well as learn from each other!

Just to get this out of the way -- PR peer review is \textbf{NOT about ensuring code style conformity}. This service is a part of the process, but it is not the point. As a peer reviewer, you should keep an eye out for such inconsistencies and make note of them. But do not let this become the focus of the review. If you see one inconsistency, make a comment at the location. If you see several, just add one comment ``check spacing throughout function (or file) xyz'' or ``variable xyz uses a dot rather than an underscore to separate words'', etc. Having 95 out of 100 comments that simply point out style issues can be frustrating for both the reviewer and the developer. Trust us, we've all been in both roles of that experience -- it is not fun! Remember -- the goal of a peer review is to write \textbf{better} code not \textbf{prettier} code. We will not mention this again 

Okay. So our goal as peer reviewers is not to be the a style police. So, what is it?

Have you ever submitted or reviewed a peer-reviewed manuscript? The premise of PR peer review is very similar.BMC describes peer review as follows:

\begin{quote}
Peer review is the system used to assess the quality of a manuscript before it is published. Independent researchers in the relevant research area assess submitted manuscripts for originality, validity and significance to help editors determine whether a manuscript should be published in their journal.
\end{quote}

Replace just a few words, and we have a pretty good description of the PR peer review:

\begin{quote}
PR peer review is the system used to assess the quality of \st{a manuscript} code before it is published. Independent \st{researchers in the relevant research area} developers assess submitted \st{manuscripts} code for \st{originality} efficiency, validity, and \st{significant} robustness to help \st{editors} package maintainers determine whether \st{a manuscript} code should be published in thier \st{journal} package.
\end{quote}

Okay, so it isn't a perfect description, but it's helpful.

To provide effective peer-review requires that the reviewer understand the field, the problem being addressed, and the proposed solution. Their responsibility is to help identify any undocumented limitations or assumptions, oversights in implementation, errors in logic, or places for improvement. It can be a demanding and time-consuming request, but it is vital to ensuring that our code base meets the needs of our users. Remember, peer reviewers are not gatekeepers, their role is to collaborate with a developer with the joint goal of ensuring that the product is as accurate, robust, and efficient as possible.

Peer review is a dialogue, not a monologue!Be respectful, responsive, and open to discussion.

\hypertarget{pull-request-submission}{%
\section{Pull Request Submission}\label{pull-request-submission}}

It is the developer's role to set the stage for an effective and efficient peer review. This means that code modifications must be well documented.

The developer is typically far more aware of the intricacies of an implementation than anyone else -- they've been working on this task for the last x hours, days, or months. As developers, we want to be kind not only to our users but also our reviewers and future developers!

Provide detailed explanations for motivation, implementation choices, and context. Point out known limitations, assumptions, bottlenecks, etc. Document these through either the initial pull request commit message and/or in the source code. For example, the initial Pull Request comment should

\begin{itemize}
\tightlist
\item
  provide a brief statement regarding the reason for the proposed modifications (bug report, feature extension, etc.)
\item
  provide a short summary of the important changes made in the code submission
\item
  recommend the order in which functions or files should be reviewed,
\item
  identify open questions or trouble spots, etc.
\end{itemize}

Note that this is meant to be an introduction for the peer reviewer -- there is no need to provide explicit details. For example

Modifications to \texttt{exampleFunction()} to address a bug report. Method failed when provided a tibble rather than a data.frame. Modified accessing functions to allow for both data.frames and tibbles.

\hypertarget{peer-review-preparation}{%
\section{Peer Review Preparation}\label{peer-review-preparation}}

Before starting any PR peer review (without looking at the proposed changes!), the reviewer should take the time to

\textbf{Understand the motivation for and need addressed by the proposed changes.}

\begin{itemize}
\tightlist
\item
  Does it address a specific bug report? What are the conditions under which the bug was encountered?
\item
  Is it a feature improvement? What was the original functionality?
\item
  Is it a package extension?
\end{itemize}

If additional information is needed, try

\begin{itemize}
\tightlist
\item
  reviewing the associated Jira task(s);
\item
  reviewing comments provided by the developer during the PR submission;
\item
  asking the developer for clarification through tracked BitBucket comments. We recommend doing this in BitBucket rather than say Slack or e-mail so that later reviewers can benefit from the conversation.
\end{itemize}

If the PR addresses a bug report or a feature extension,

\textbf{Understand the original function to which the proposed changes are being made.}

\begin{itemize}
\tightlist
\item
  What is the purpose of the affected function?
\item
  What assumptions were made in the original implementation?
\item
  Are there any inconsistencies with current guidelines? (e.g., uses \texttt{magrittr} pipes rather than native pipes)
\item
  Are there any design or implementation choices that could be modified to improve user interaction, efficiency, or robustness?
\end{itemize}

Make notes. Maybe create a list of things to keep an eye out for when looking at the proposed changes. The primary purpose here is to ensure that the context in which the proposed changes are being made is fully understand.

If it turns out that items identified as possible limitations or points for improvement are not addressed by the current PR, include them in final comments so the team can discuss and perhaps incorporate them into the current PR or submit them as Jira tasks for future development.

If the PR is a new feature

\textbf{Understand the theory behind the new feature.}

This might be a significantly more time-consuming burden on the reviewer. Exactly what this means depends on the new feature. For example,

\begin{itemize}
\tightlist
\item
  Is it a new performance metric or regression method? Review and understand the governing equations as provided by the submitting developer. Work through the algebra/calculus. Review the relevant sections of the supporting references.
\item
  Is it a new plotting function for specific returned value object? Review and understand the function that creates the object to be plotted.
\item
  Is it a new Rmd doc? Review and understand the purpose and application for which the document will be used.
\end{itemize}

The preparation step gives us the foundation needed to provide thoughtful, comprehensive, and helpful feedback to the developer.

\hypertarget{map-out-your-own-approach}{%
\section{Map Out Your Own Approach}\label{map-out-your-own-approach}}

Without going into fine detail, ask yourself how you would/could address the proposed code changes. If the PR is addressing a reported bug, how would you correct it? If it is a feature extension, how would you incorporate it into the original function? If it's a new feature, what are the key steps that define the procedure?

Having these answers in mind during the review can help to identify unintended assumptions or limitations made in either our approach or the developer's solution as well as potentially identify or learn more efficient implementation and design choices.

Again, we are not recommending that you actually write code here. Just spend some time thinking about how you would complete the task.

Developing our own solution before looking at the proposed changes helps us to avoid locking onto the implementation choices made by the developer.

\hypertarget{review-the-proposed-changes}{%
\section{Review the Proposed Changes}\label{review-the-proposed-changes}}

Now we get to the nitty gritty of PR peer review. At this stage, take your first look at the proposed changes. Initially, you should simply want to understand the proposed code and determine if it is valid and accurate. This is not the time to consider alternative solutions. Ask:

\begin{itemize}
\tightlist
\item
  Are the proposed changes valid code?
\item
  Do they address the bug or incorporate the feature as specified?
\item
  Do they respect the assumptions stated in the documentation?
\item
  Does the new code introduce new assumptions?
\item
  Are there any unintended or undocumented limitations?
\item
  Are inputs tested?
\item
  Are intermediate results tested before use?
\item
  Is there sufficient unit testing of new code?
\item
  Are edge cases considered?
\item
  Are NA/NaN/Inf conditions addressed?
\item
  Are style conventions followed?
\end{itemize}

If something about the proposed changes is unclear, take some time to pull the branch and step through the function or ask the developer (through a comment in BitBucket) to clarify. If clarification is needed, be clear and detailed in your question: what is your current understanding; what aspect or result is not clear; etc. Comments are typically read by all reviewers in a PR process, so keep future reviewers in mind when formulating your questions.

First, ensure the accuracy and validity of the proposed changes.

\hypertarget{discuss-alternative-solutions}{%
\section{Discuss Alternative Solutions}\label{discuss-alternative-solutions}}

At this stage, you should be confident that the implementation is meeting the requested need and that it is accurately implemented or that any deficiencies have been identified during the review. Now, consider the questions of generality, robustness, and efficiency. This is when questions about alternative implementation and design choices should be considered. The ``map your own approach'' step is often helpful.

\begin{itemize}
\tightlist
\item
  Can any step be implemented using different tools? If yes, identify the advantages and limitations of those alternative w.r.t. the proposed implementation.
\item
  Would a different design be more maintainable or efficient?
\item
  Should intermediate steps be pulled out to improve unit testing coverage?
\item
  Are there aspects of one implementation that are more general, extendable, efficient, or robust than the other?
\end{itemize}

The purpose of this stage is not to push your personal coding preferences on the developer. This step is meant to facilitate a discussion between you and the developer to ensure that the tool is robust, general, and efficient. It also can help us to better understand the impact of design choices, avoid unintentional implementation assumptions, and recognize points of optimization and generalization in our own development efforts.

If it is believed that an alternative solution should be considered, add a detailed comment providing at least a skeleton of the suggested alternative. Any advantages or limitations of the alternate solution as they compare to the proposed solution should be detailed. For example, ``I have found that \texttt{abc} is often slower for large datasets than \texttt{xyz}. Will that be a concern here?''

Feel free to also share equivalent solutions solely for the purposes of discussion -- ``This is great! I typically would have used \texttt{abc} because of \texttt{xyz}, but I see no strong reason to do to so here.'' Maybe the developer is not familiar with \texttt{abc}. Or, maybe the developer considered it but opted for another solution because \texttt{xyz} is not valid in the context. \textbf{This is the stage of peer review during which we learn the most from one another!}

It is through the discussion of ideas that we, as a team, learn, grow, and succeed.

  \bibliography{book.bib,packages.bib}

\end{document}
